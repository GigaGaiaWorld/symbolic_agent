下面是在“Rule 章修订版 v2”的基础上做的定点修订：删除 `bodies` 字段与相关表述，改为仅使用 `where` 一个字段，并规定 **一层 list = 单 body（AND）**，**两层 list = OR-of-bodies（外层 OR，内层 AND）**；同时补齐硬约束（禁止混合深度、禁止三层嵌套、空 body 处理），其余内容保持不变。

---

# Rule & Derivation 最终设计文档（Rule 章修订版 v3）

## 2. 统一 DSL：head + where（Rule 与 Derivation 共用）

我们采用 Horn clause 风格的声明式 DSL：`where` 描述约束（AND/OR 结构），`select/head` 描述输出形状（输出变量绑定）。本系统将“用户面向的 DSL”与“引擎面向的谓词 head”解耦：用户可以不显式写 head，但编译器在内部仍会生成可执行的 head 谓词承载结果集。

### 2.1 变量与约束

* `vars()` 产生逻辑变量（LogicVar），变量复用表示 join
* `== != < <= > >=` 生成 builtin/constraint
* 路径表达式 `Entity(var).field` 或 `record.field` 编译为谓词原子（映射到 View 业务谓词；命名见《视图层.md》，`*_view` 仅作为可选别名）

约定：逻辑约束统一使用 `==/!=/...`。不使用 `=` 表达约束（避免赋值歧义）。

### 2.2 规则安全性（必须）

Safety / range-restricted（强制）：

1. `select` / `head` 中出现的所有变量必须在 `where` 的**正原子**中出现并可绑定
2. builtin 比较仅允许 value 域，且必须符合 `SchemaIR` 定义；EntityRef 仅允许 `==/!=`，禁止 `<` 等序比较
3. 不支持“规则内生成新常量/新实体 id”（不支持存在变量/Skolem）
4. 否定（Negation）：MVP 默认不支持 `not`；若未来支持，必须为 Stratified Negation，并进入方言能力矩阵
5. 聚合（Aggregation）：MVP 默认不支持在规则内使用 `count/min/max`（尤其不用于策略确定化/选优）；如需聚合选择，走 `policy_mode="edb"` 预计算或作为后续扩展能力单独规范

### 2.3 where 的结构语义（定稿：仅一个字段，支持顶层 OR）

为便于前端对接，本系统使用 `where` 字段表达：

* **一层 list**：表示单个 body（AND）
  `where = [A1, A2, ...]` 语义为 `A1 ∧ A2 ∧ ...`
* **两层 list**：表示顶层 OR-of-bodies（外层 OR，内层 AND）
  `where = [[B11, B12, ...], [B21, B22, ...], ...]`
  语义为 `(B11 ∧ B12 ∧ ...) ∨ (B21 ∧ B22 ∧ ...) ∨ ...`

硬约束（必须）：

* 若 `where` 为两层 list，则外层每个元素都必须是 list，且内层元素必须为原子/约束（不得再出现 list）
* 三层及以上嵌套一律报错（MVP 不支持括号嵌套布尔表达式）
* `where=[]` 或出现空 body `[]` 一律报错（避免无约束全域输出）
* 编译器必须将两层 list 展开为多条 Clause（同 head/同 select）.

---

## 3. Rule：纯推导（IDB）规范

### 3.0 Rule 的两种用户入口（定稿）

为匹配前端交互（用户“给一个 rule 名 → 写条件 → 看结果”），Rule 默认入口为 **Rule（无显式 head）**：

* **Rule（默认）**：用户提供 `id@version`、`select`、`where`；系统编译期自动生成内部 head 承载结果集。默认仅用于查询，不参与物化。

此外，为支持“引用其他 rule”，Rule 可选设置 `expose=True` 将其结果作为可调用谓词暴露出来（仍不参与物化）。

> 资产身份：Rule 与 Derivation 在规格层面均以 `spec_key=(id,version)` 为第一身份，统一纳入版本化管理（active/disabled/deprecated），用于运行/缓存/复现与审计入口。

---

### 3.1 标准写法（单分支，Rule）

假设已定义以下 Entities（关系用 reified 实例 Entity 表达，并具备 uid identity）：

```python id="qjzv7e"
from factpy import Entity, Identity, Field

class Language(Entity):
    source_system: str = Identity(default="ISO639")
    code: str = Identity()
    name: str = Field(cardinality="multi")

class Country(Entity):
    source_system: str = Identity()
    source_id: str = Identity()

class Person(Entity):
    source_system: str = Identity()
    source_id: str = Identity()
    name: str = Field(cardinality="multi")

class HasLanguage(Entity):
    uid: str = Identity(default_factory="uuid4")
    country: Country = Field(cardinality="functional")
    language: Language = Field(cardinality="functional")

class LivesIn(Entity):
    uid: str = Identity(default_factory="uuid4")
    person: Person = Field(cardinality="functional")
    country: Country = Field(cardinality="functional")
```

定义一个查询型 Rule（引擎计算 IDB 结果，不写回 EDB）：

```python id="ehfpnt"
from factpy import Rule, vars

with vars() as (p, c, l, li, hl):
    R = Rule(
        id="q_person_speaks_language",
        version="1.0.0",
        select=[p, l],
        where=[
            LivesIn(li),
            HasLanguage(hl),

            li.person == p,
            li.country == c,

            hl.country == c,
            hl.language == l,
        ],
    )

rows = store.run(R)   # -> [(p1, de), (p1, en), ...]
```

或更简洁的写法
```python id="rfts2"
		where=[ 
			LivesIn(l).person == LivesIn(li).person, 
			LivesIn(li).country == HasLanguage(h).country, 
			LivesIn(l).person == p, HasLanguage(h).language == l
		],
```

说明：

* 用户不写 `head`，因为对用户而言 `id@version` 是该规格的第一身份（spec_key）
* 底层逻辑引擎仍需要一个 head 来承载结果集，因此编译器会生成内部 head（例如 `__q__q_person_speaks_language__v1(p,l)`）用于执行与结果回收；该内部 head 不暴露为业务谓词，也不参与物化. 

#### where 中包含比较与计算（示例）

```python id="r1wjdq"
with vars() as (p, by, age):
    R = Rule(
        id="q_adults",
        version="1.0.0",
        select=[p, age],
        where=[
            Person(p).birth_year == by,
            age == (2026 - by),
            age >= 18,
        ],
    )
```

---

### 3.2 多分支（OR）规范（使用两层 where）

多个分支表示同一输出关系的多条推导路径（并集语义）。在本系统中，OR 分支使用两层 `where` 表达：

```python id="j4l5f4"
from factpy import Rule, vars

with vars() as (p, c, l, li, hl):
    R = Rule(
        id="q_person_speaks_language",
        version="1.1.0",
        select=[p, l],
        where=[
            [  # 分支 A：按国家语言推导
                LivesIn(li), HasLanguage(hl),
                li.person == p,
                li.country == c,
                hl.country == c,
                hl.language == l,
            ],
            [  # 分支 B：另一条推导路径（示意）
                # ...
            ],
        ],
    )
```

编译器必须将两层 `where` 展开为多条 Clause（同内部 head，不同 body），不得保留 OR 节点。

关于去重与选优（精确定义）：

* 对完全相同的结果 tuple，可在执行/收集阶段按集合语义去重（建议 rows 去重）
* 系统不会自动做“选优/确定化”或跨值合并
* 若未来这些结果用于写回（accept 阶段），functional/mapping 冲突必须交给 policy（chosen/canon_policy）确定化；若无可用策略则拒绝/报错

---

### 3.3 引用其他 Rule（RuleRef）

要在一个规则中复用另一个规则的结果，被引用规则必须对应一个“可调用谓词”。Rule 默认仅查询, 若设置 `expose=True`，则编译期生成并注册一个可引用的内部谓词. 即:
- **Rule（无 head）其实是 QuerySpec**：它是“可执行查询规格”，不是用户可引用的业务谓词。
- 只有 `expose=True` 的 Rule 才会注册一个可引用谓词（你已经写了），这时它才表现得像传统 Horn rule 的 head。

推荐用户 API：`RuleRef(id, version)(args...)` 作为 where 中的原子。

```python id="ij93o6"
from factpy import Rule, Rule, RuleRef, Pred, vars

with vars() as (p, c, l, li, hl):
    speaks = Rule(
        id="q_speaks_candidate",
        version="1.0.0",
        select=[p, l],
        where=[
            LivesIn(li), HasLanguage(hl),
            li.person == p,
            li.country == c,
            hl.country == c,
            hl.language == l,
        ],
        expose=True,
    )

with vars() as (p, l1, l2):
    Rule(
        id="r_is_polyglot",
        version="1.0.0",
		select=[p],
        where=[
            RuleRef("q_speaks_candidate", version="1.0.0")(p, l1),
            RuleRef("q_speaks_candidate", version="1.0.0")(p, l2),
            l1 != l2,
        ],
    )
```

版本策略：默认推荐引用固定版本以保证可复现。若允许 `latest_active`，必须在 RunAudit 中记录解析后的具体版本闭包。



---

## 5. Derivation：候选 + 显式物化（materialize 细节后置）

本节定义 Derivation 的语义边界、用户写法、候选输出契约，以及与 Rule/where 的关系。物化（accept）如何写回 EDB 的细节（fact/record 写入形态、id_policy/dedupe_policy、functional 冲突处理、provenance meta 完整字段等）放在后续章节展开。

### 5.1 Derivation 的定位

Derivation 不是“另一种 Rule”；它是一个可执行规格（spec），用于把推导结果组织成“候选产物（CandidateSet）”，并提供显式物化入口。

Derivation 定义两阶段动作：

* evaluate → CandidateSet: `evaluate()` 运行推导，输出 CandidateSet（不写 EDB）
* accept → 写回 EDB: `accept()` 显式物化写回 EDB（append-only），并保证幂等（细节后置）

这两个动作由运行时执行器（Store）提供 API：`store.evaluate(derivation)` 与 `store.accept(candidates, ...)`. 推荐的最终 API 形式（你们文档应这么写）

1. 运行 Derivation 得到候选（不写 EDB）
```python
cands = store.evaluate(SpeaksDerive, policy_mode="edb")
print(cands.run_id)           # 用于审计/对比
```
2. 显式物化候选（写回 EDB，append-only，幂等）
```python
res = store.accept(cands, meta_overrides={"approved_by":"admin"})
print(res.materialize_id)     # 审计/追溯
print(res.assertion_ids)      # 写回的 A 列表（或 digest）
```

Derivation 的 `where`/条件表达式与 Rule 使用相同 DSL，且其第一身份同样由 `spec_key=(id,version)` 决定并参与版本化管理（active/disabled/deprecated）。

但 Derivation 必须指定 `head`（keyed head），原因是：

1. `head` 定义候选输出的键与形状（Candidate contract）
2. `head` 绑定物化目标（写回哪个业务谓词 / 哪个 reified Entity 类型）
3. `head` 提供 accept 幂等去重的基准（fact_key / record_uid 的输入）

### 5.1.1 where 的结构语义（与 Rule 完全一致）

Derivation 的 `where` 仅使用一个字段表达 AND/OR：

* 一层 list：单个 body（AND）
  `where = [A1, A2, ...]` 语义为 `A1 ∧ A2 ∧ ...`

* 两层 list：顶层 OR-of-bodies（外层 OR，内层 AND）
  `where = [[B11, ...], [B21, ...], ...]`
  语义为 `(B11 ∧ ...) ∨ (B21 ∧ ...) ∨ ...`

硬约束（必须）：

* 若 `where` 为两层 list，则外层每个元素都必须是 list，且内层元素必须为原子/约束（不得再出现 list）
* 三层及以上嵌套一律报错（MVP 不支持括号嵌套布尔表达式）
* `where=[]` 或出现空 body `[]` 一律报错（避免无约束全域输出）
* 编译器必须将两层 list 展开为多条 Clause（同 head/同 target），不得保留 OR 节点

### 5.1.2 CandidateSet 最小输出契约（必须）

即使物化细节后置，Derivation.evaluate 的输出必须满足最小契约，以支撑 UI 展示、审计与可复现。

每条 candidate 至少包含：

* `derivation_id`, `derivation_version`（即 spec_key）
* `run_id`（或 trace_id）
* `target`（业务谓词或 entity type）
* `key_tuple_canonical`（由 head 的 keyed fields 生成）
* `support_digest`（并标注 `support_kind=exact|approx`）
* `generated_at`
* `state`（`new/accepted/rejected/superseded`）

去重键建议（默认）：

* `cand_key = (derivation_id, derivation_version, target, key_tuple_canonical)`

说明：CandidateSet 是“候选池/运行产物”，不进入业务 view。只有 accept 后写回 EDB 的事实/record 才会在 view 查询中可见。

硬约束（MVP，必须）：

* 每条 candidate 必须额外包含 `key_tuple_digest="sha256:<64hex>"`，其计算为 `sha256(typed_tuple_v1.canonical_bytes(key_terms))`；`key_terms` 的顺序锁死为 Derivation.head 的 keyed fields 顺序，且每个 term 的 Tag/Val canonicalization 必须满足《断言层/证据层》`typed_tuple_v1` 规范。
* 每条 candidate 必须携带 accept 写回 payload：`subject`（canonical EntityRef）与 `rest_terms[]` 的逐项 `(Idx,Tag,Val)`（或等价的完整 `claim_arg` 行）；并同时提供 `tup_digest="sha256:<64hex>"` 用于校验写回的 `typed_tuple_v1(rest_terms)`。
* accept 幂等/去重时不得使用自由格式展示串；必须使用 `key_tuple_digest`（或以其为输入构造 `cand_key_digest`），以保证跨语言/跨引擎可复现。

### accept 写回协议（MVP）与 Store API（最小合约）

本节把 “候选 → 写回 EDB（append-only）” 的 accept 行为钉死为最小可实现合约：accept **只追加**证据层事实（`claim + meta`，必要时追加 `revokes`），不得就地更新；并且必须幂等、可审计、跨引擎可移植。

#### 1) accept 输入/输出契约（结构化字段清单）

accept 的规范输入为三元组（硬规范，必须）：

- **输入：DerivationSpec**
  - 至少包含：`derivation_id`、`derivation_version`、`materialize_as`、`target`（PredId 或 record entity type）、以及在 `materialize_as="record"` 时必填的 `id_policy`。
  - 说明：Store 可以以“已注册的 derivation_ref”解析出 DerivationSpec；也可以直接随调用传入，但不得出现“CandidateSet 与 DerivationSpec 不匹配”而静默继续。

- **输入：CandidateSet**
  - 至少包含：`derivation_id`、`derivation_version`、`run_id`、`target`、`candidates[]`。
  - 每条 candidate 至少包含（用于写回与幂等，缺一不可）：
    - `key_tuple_canonical`：候选的 group_key（由 head 的 keyed fields 生成；必须保持**有序**与**可复现**）。
    - `support_digest`、`support_kind`（`exact|approx`）。
    - 写回所需的值域（至少能构造出目标 claim 的 `S` 与 `rest_terms`）：若缺失则属于 schema violation（见失败类）。

- **输入：accept_options**
  - 最小字段（必须支持）：
    - `approved_by? : string`
    - `note? : string`
    - `dry_run? : bool`（默认 `false`）
  - 约束：同一 `CandidateSet` 的重试 accept 不得改变会写入 meta 的字段（例如 `approved_by/note`）；否则必须拒绝（schema violation），避免“同一幂等键不同写入”。

**输出：AcceptResult**（硬规范，必须包含以下字段）：

- `materialize_id : string`
- `run_id : string`
- `accepted_count : int`（本次调用**新增写入**的 candidate 数量；`dry_run=true` 时为 0）
- `skipped_count : int`（本次调用未写入的 candidate 数量）
- `written_assertions[]`：本次调用新增写入的断言摘要（每项至少包含）：
  - `asrt : AssertionId`
  - `pred_id : PredId`
  - `key_tuple_canonical`（与 candidate 相同；用于审计/UI 复现）
- `skipped_reason_counts : { reason -> int }`（例如：`duplicate`, `dry_run`）

**materialize_id 生成（硬规范）**：

- Store 必须为一次 accept 生成 `materialize_id`，且对同一 `CandidateSet(run_id, derivation_id, derivation_version)` 的重复 accept 生成结果必须一致（用于幂等重试）。
- 推荐（且可直接实现）的确定性生成：
  - `materialize_id = "mat_v1:" + sha256_hex( b"factpy\\x00mat_v1\\x00" + utf8(run_id) + b\"\\x00\" + utf8(derivation_id) + b\"\\x00\" + utf8(derivation_version) + b\"\\x00\" )`

**失败（3 类错误，硬规范）**：

- `schema_violation`：输入结构不满足本节契约（缺字段/错类型/PredId 不在 SchemaIR/typed_tuple_v1 与 Tag 规范不一致/`entity_ref` 非 `idref_v1:` 等）。
- `policy_non_determinism`：写入后会触发 functional/mapping 的 chosen/确定化，但所需 tie-break 信息缺失或引擎无法保证确定性（例如 policy 需要 `confidence/source_rank` 但 candidate/accept_options/meta 无法提供）。
- `engine_capability`：目标执行/导出引擎不支持必要能力（例如不支持 `typed_tuple_v1` Tag 某类型且无允许的降级策略，或不支持 policy_mode 要求）。

失败审计（硬规范）：

- 任一失败必须写入 `accept_failed` 审计记录（至少包含：`run_id`、`materialize_id`、`error_class`、`message`、`derivation_id@version`、以及可定位的 candidate 摘要）。
- 失败时**不得**写入任何 `claim/meta/revokes`（全失败，不允许部分写入后报错）。

#### 2) 写回形态：fact vs record（写死 claim 写哪些 PredId/参数）

accept 的唯一写入点是证据层 `claim/4`（以及对应 meta_*）。写回必须满足 `/Users/zhenzhili/symbolic_agent/docs/断言层 证据层.md` 的：

- `claim(Asrt, PredId, S, O)` 结构；
- `S` 为 canonical EntityRef token；
- `O = typed_tuple_v1(rest_terms)` 且顺序与 SchemaIR.arg_specs 对齐；
- `claim_arg` 默认由 EDB 端物化（见证据层“claim_arg 默认物化策略”）。

**2.1 物化为 fact（业务谓词目标）**：

- 对每条被 accept 的 fact candidate，必须追加写入：
  - `claim(Asrt, PredId, E, typed_tuple_v1(rest_terms)).`
- 其中：
  - `PredId`：目标业务谓词（例如 `"person:country"` / `"user:speaks"`）。
  - `E`：subject（EntityRef），必须为 `/Users/zhenzhili/symbolic_agent/docs/规范.md` 规定的 canonical `idref_v1:...` token。
  - `rest_terms`：**严格等于** SchemaIR 对该 PredId 的参数序列去掉 `E` 后的剩余项，且顺序一致；不得交换/省略/补默认值。
- `claim_arg`：必须为该 `O` 生成逐项解包索引 `claim_arg(Asrt,Idx,Val,Tag)`（默认 EDB 物化；见证据层 `typed_tuple_v1 与 claim_arg`）。

**2.2 物化为 record（reified Entity 目标）**：

- 对每条被 accept 的 record candidate，必须写入至少两类 claim（硬规范）：

  a) **记录锚点（存在性）claim**（二选一写死，本系统采用以下形式）：
  - `claim(Asrt0, "<record_type>:exists", R, typed_tuple_v1([])).`

  b) **角色谓词（role facts）claim**：对 record 的每个 role 字段写入一条（示例命名；实际 PredId 必须由 SchemaIR 注册表提供）：
  - `claim(Asrt1, "<record_type>:person",   R, typed_tuple_v1([E])).`
  - `claim(Asrt2, "<record_type>:language", R, typed_tuple_v1([L])).`

- 其中 `R` 的生成（硬规范）：
  - `R` 必须是 canonical EntityRef token（`idref_v1:...`），其 `entity_type=<record_type>`。
  - `R` 必须由 `id_policy` 幂等生成：`id_policy` 定义了用于 identity 的**有序字段序列**与类型标签；其 canonicalization 与哈希规则必须复用 `/Users/zhenzhili/symbolic_agent/docs/规范.md` 的 IdentityPolicy/EntityRef 规范（不得另起一套“record uid”规则）。

#### 3) 幂等与去重：必须复用证据层策略（硬约束）

幂等键（硬规范）：

- accept 的幂等域为 `(materialize_id, cand_key)`。
- `cand_key` **必须可复现**且来自 `CandidateSet.key_tuple_digest`（`sha256:<64hex>`），并且必须覆盖：
  - `PredId`（或 record_type 的落地 PredId 族）
  - group_key 的全部参数（key_tuple 的每个元素）
- 缺失上述任何信息必须拒绝（schema violation）。

落地规则（硬规范）：

- Store 必须为每个 candidate 计算 `cand_key`（推荐用 digest 形态，避免跨语言字符串转义差异）：
  - `cand_key_digest = sha256_hex( b"factpy\\x00cand_key_v1\\x00" + utf8(PredId) + b\"\\x00\" + utf8(key_tuple_digest) + b\"\\x00\" )`
  - 并将其作为 `cand_key_digest` 写入 meta（若你们能稳定表示 `cand_key` 文本，也可写 `cand_key`；但两者语义必须一致）。
  - 硬约束：`key_tuple_canonical` 仅用于展示，不得作为 accept 幂等/去重/digest 的输入。
- 对同一 `(materialize_id, cand_key_digest)` 的重复 accept 必须 **no-op**：
  - 不得追加新的 claim；
  - 必须返回已存在的 `written_assertions` 摘要，并在 `skipped_reason_counts["duplicate"]` 计数。
- `dry_run=true`：
  - 不得写入任何 claim/meta；
  - 仍必须生成并返回 `materialize_id`；
  - 必须返回“将要写入”的 `written_assertions` 摘要（用于 UI 预览）；可选写入 `accept_dry_run` 审计记录。

#### 4) 冲突处理（functional/mapping）与 chosen 的关系

- accept **不直接决定 chosen**：accept 只追加 `claim + meta`，chosen 的确定化由 policy/view 决定（见《视图层.md》与证据层 chosen 规则）。
- functional 冲突：
- 若 `policy_mode="idb"`，引擎必须能提供确定性 chosen；否则必须拒绝（policy_non_determinism）。
  - 若 `policy_mode="edb"` 且 chosen 需要 tie-break 但缺少必需 meta（例如 `confidence/time/source_rank`），accept 必须拒绝（policy_non_determinism），不得“先写入再让 chosen 随缘”。
- mapping（如 `canon_of`）：
  - 必须单值且确定；若 accept 将在同一 key 下产生多值且 policy 无法确定 chosen，必须拒绝（policy_non_determinism）。

#### 5) 写回 meta 最小集合（硬规范）

每条 accept 写回的 Asrt（包括 record 锚点与 role facts）必须写入以下 meta（作为 `meta_*`；硬规范）：

- `meta_str(Asrt,"derived_rule_id",...)`
- `meta_str(Asrt,"derived_rule_version",...)`
- `meta_str(Asrt,"run_id",...)`
- `meta_str(Asrt,"materialize_id",...)`
- `meta_str(Asrt,"cand_key_digest",...)`（或 `cand_key`；二选一，但必须满足证据层“幂等键”要求）
- `meta_str(Asrt,"support_digest",...)`
- `meta_str(Asrt,"support_kind",...)`
- `meta_str(Asrt,"approved_by",...)`（可选）
- `meta_str(Asrt,"note",...)`（可选；作为用户自定义 key，但不得覆盖任何保留 key）

并且必须复用证据层写入协议的“保留 key 不可覆盖/不可删/不可改类型”规则（见《断言层 证据层.md》`meta keys 最小保留集合`）。

#### 6) Store API（最小合约）

以下方法是 Store 的最小对外契约（字段为最小必备；可以添加扩展字段，但不得删减或改语义）：

- `run(rule_or_derivation_ref, inputs?, options?) -> RunResult`
  - 返回最小字段：`run_id`, `outputs_ref`, `diagnostics`（errors/warnings, engine_info）

- `evaluate(derivation_ref, inputs?, options?) -> CandidateSet`
  - 返回最小字段：见本章 `CandidateSet 最小输出契约`（必须包含 `run_id/target/key_tuple_canonical/support_digest/support_kind`）

- `accept(derivation_ref | candidate_set, candidate_set?, accept_options) -> AcceptResult`
  - 若只传 `candidate_set`，Store 必须能从中解析 `derivation_id@version` 并取到 DerivationSpec（或在 CandidateSet 内携带）

- `explain_fact(pred_id, args..., mode?) -> Explanation`
  - 返回最小字段：`chosen_asrt`、`candidates[]`（冲突组内备选 Asrt）、每条 Asrt 的关键 meta（至少含 `source/ingested_at/materialize_id/run_id/support_digest`）、以及来源链（可递归或以 digest/refs 表示）

- `conflicts(pred_id, group_key..., mode?) -> ConflictReport`
  - 返回最小字段：`group_key`、`active_asrts[]`、`chosen_asrt?`、以及冲突原因/排序依据摘要（用于审计）

- `export_package(target_engine, options?) -> ExportPackage`
  - 返回最小字段：`manifest_path`, `digests`（至少包含 `schema_digest/edb_digest/rules_digest/policy_digest/support_digest`）

#### 7) 最小示例（端到端 1 个）

evaluate → CandidateSet（只示关键字段）：

```json
{
  "derivation_id": "speaks_candidate",
  "derivation_version": "1.1.0",
  "run_id": "run_20260302_001",
  "target": "user:speaks",
  "candidates": [
    {
      "key_tuple_canonical": "(idref_v1:User:..., \"de\")",
      "support_digest": "sd_...",
      "support_kind": "exact",
      "values_for_writeback": {
        "E": "idref_v1:User:...",
        "rest_terms": [{"tag":"string","val":"de"}]
      }
    }
  ]
}
```

accept → AcceptResult（只示关键字段）：

```json
{
  "materialize_id": "mat_v1:...",
  "run_id": "run_20260302_001",
  "accepted_count": 1,
  "skipped_count": 0,
  "written_assertions": [
    {"asrt":"A300","pred_id":"user:speaks","key_tuple_canonical":"(idref_v1:User:..., \"de\")"}
  ],
  "skipped_reason_counts": {}
}
```

写回的一条 claim + 相关 meta（示意；meta key 命名必须与证据层一致）：

```
claim(A300, "user:speaks", idref_v1:User:..., typed_tuple_v1([string("de")])).
meta_time(A300,"ingested_at",1772446272123456789).
meta_str(A300,"source","derivation.accept").
meta_str(A300,"trace_id","run_20260302_001#accept").
meta_str(A300,"schema_digest","...").
meta_str(A300,"policy_digest","...").
meta_str(A300,"derived_rule_id","speaks_candidate").
meta_str(A300,"derived_rule_version","1.1.0").
meta_str(A300,"run_id","run_20260302_001").
meta_str(A300,"materialize_id","mat_v1:...").
meta_str(A300,"cand_key_digest","...").
meta_str(A300,"support_digest","sd_...").
meta_str(A300,"support_kind","exact").
meta_str(A300,"approved_by","alice_admin").
```

最终硬约束：`accept` 写回必须与 `/Users/zhenzhili/symbolic_agent/docs/断言层 证据层.md` 的“撤销模型 + 幂等键 + claim_arg 默认物化策略”一致；若需要变更，必须同时 bump protocol_version 并更新 `/Users/zhenzhili/symbolic_agent/docs/导出与运行.md` 的 manifest 版本。

### 5.2 Derivation 定义（用户友好 head：不暴露 Key(...)）

为降低用户心智负担，Derivation 允许使用统一的 head 写法 `Speaks(person=p, language=l)`，并由 `materialize_as` 决定最终落地目标（fact 或 record）。判定规则如下（硬规范）：

1. `materialize_as` 必填，且优先级最高
	- 系统不得在未提供 `materialize_as` 时对 `Speaks(...)` 自动猜测目标类型（避免歧义）。
	
2. `materialize_as="record"`：head 必须是 EntityType（reified record）
	- `head=Speaks(person=p, language=l)` 表示候选键为 `(p,l)`；accept 时创建/复用 `Speaks(uid)` record，并写入角色事实（append-only）：
	    - `speaks_person(S, p)`
	    - `speaks_language(S, l)`
	- `id_policy` 必填，用于幂等生成 record uid，避免重复 accept 产生重复实例。
    
3. `materialize_as="fact"`：head 解析为业务谓词目标
	- 若 head 是 `Person.speaks(...)`（PredRef），则目标谓词固定为该业务谓词（无歧义）。
	- 若 head 是 `Speaks(...)`（EntityType），则必须存在其 canonical **projection predicate**（由 SchemaIR 提供 `projection_pred_id` 与参数顺序），物化时写入该投影谓词的事实（而不是创建 record）。
    
4. SchemaIR 需求（必须）
	- 对每个可作为 fact 目标的 record entity，SchemaIR 必须提供：
	    - `projection_pred_id`（例如 `speaks/2` 的 canonical pred_id）
	    - `projection_arg_order`（由哪些 role fields 组成投影参数顺序）

说明：`Person.speaks(...)` 永远是 fact 目标；`Speaks(...)` 可同时支持 fact/record，两者仅由 `materialize_as` 切换，语义稳定且可审计。

请注意 `head` 在语法上必须是**纯构造表达式**，不得触发任何写入或注册副作用；并且不得复用与普通 Field setter 相同的 API
#### 5.2.1 物化为 fact：业务谓词目标

示例：推导“某人会说某语言”，目标是业务谓词 `person:speaks/2`。

```python id="1j2kq7"
from factpy import Derivation, vars

with vars() as (p, c, l, li, hl):
    SpeaksDerive = Derivation(
        id="speaks_from_country_language",
        version="1.0.0",
        head=Person.speaks(person=p, language=l),   # keyed head：输出键 (p,l)，target=业务谓词
        where=[
            LivesIn(li), HasLanguage(hl),
            li.person == p,
            li.country == c,
            hl.country == c,
            hl.language == l,
        ],
        materialize_as="fact",
        status="active",
    )
```

evaluate 产生候选 `(p,l)`；accept（后续章节详述）将候选显式写回为 `person:speaks(p,l)` 的 EDB 断言（claim+meta）。

#### 5.2.2 物化为 record：reified Entity 目标

示例：目标是 reified 关系实例 `Speaks(Entity)`，便于挂属性与审计。

```python id="u5m1y8"
from factpy import Entity, Identity, Field, Derivation, vars

class Speaks(Entity):
    uid: str = Identity(default_factory="uuid4")
    person: Person = Field(cardinality="functional")
    language: Language = Field(cardinality="functional")

with vars() as (p, c, l, li, hl):
    SpeaksDeriveRec = Derivation(
        id="speaks_from_country_language",
        version="1.0.0",
        head=Speaks(person=p, language=l),  # keyed head：输出键 (p,l)，target=reified Entity 类型
        where=[
            LivesIn(li), HasLanguage(hl),
            li.person == p,
            li.country == c,
            hl.country == c,
            hl.language == l,
        ],
        materialize_as="record",
        # record 模式必须提供 id_policy（细节在后续章节）
        status="active",
    )
```

evaluate 仍产生候选 `(p,l)`；accept 将候选显式物化为一个 `Speaks(uid)` 实例并写入其 role facts（以及 provenance meta）。

#### 5.2.3 语义消歧（硬规范）

为避免误解与副作用，本系统规定：

1. 在 `Derivation(head=...)` 位置：
	* `Person.speaks(person=p, language=l)` ，目标为业务谓词（fact）
	* `Speaks(person=p, language=l)` ，目标为 reified Entity 类型（record）
	  两者都不表示“立即创建实例”。

2. 实例创建只发生在 `accept()` 且 `materialize_as="record"` 时：
   由 `id_policy` 幂等生成 uid（避免重复 accept 产生重复实例）。

3. `materialize_as="record"` 强制要求 `id_policy`：
   未提供则 validate 阶段必须报错（幂等要求）。

### 5.3 Entity 内联挂载 Derivation（语法糖，必须无副作用）

允许将 Derivation 作为“声明/入口”挂载到 Entity 上以提升可发现性与便于注册，但这只是纯声明，不是运行时行为：

* 类定义阶段不得自动 `register/evaluate/accept`（禁止 import-time 副作用）
* 运行必须通过显式 `store.register_derivation(...)` 才能生效
* Derivation 仍以 `id@version` 版本化管理，与 facts 不混存

示意（内联式，仅作为入口）：

```python id="v3a4t0"
class Speaks(Entity):
    uid: str = Identity(default_factory="uuid4")
    person: Person = Field(cardinality="functional")
    language: Language = Field(cardinality="functional")

    derivations = [
        Derivation(
            id="speaks_from_country_language",
            version="1.0.0",
            head=Speaks(person=p, language=l),
            where=[...],
            materialize_as="record",
            status="active",
        )
    ]
```

推荐实践（更稳）：类内仅放引用 `DerivationRef(...)`，Derivation 在 registry 模块集中定义与注册（避免 schema 与 runtime 耦合）。

### 5.4 与 Rule 的关系（组合方式）

* Rule（含 Rule）用于“即时推导/查询/中间关系”，默认不进入候选池，也不写回 EDB。
* Derivation 复用同一 DSL 计算候选键（可视为内部编译生成候选谓词并求值），然后将结果纳入 CandidateSet 的治理流程（evaluate → 人工/程序筛选 → accept）。

> 注意：Derivation 不要求你先定义一个可见的 `SpeaksCandidate` 规则；它可以直接内联 where。若需要模块化复用，则可配合 `RuleRef(...)` 引用已暴露的中间规则（见 3.3）。

---
