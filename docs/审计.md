下面把你们系统里“应该审计的东西”按控制面/数据面分门别类整理成一套完整目录。每一类都给一个直观例子（包含：记录什么、怎么产生、怎么查询回溯）。示例会严格贴合你们现有的核心语义：append-only `claim/meta/view`、policy_mode(edb/idb)、canon_policy、Candidate→accept 物化、规则版本化。

注：本文示例中的 `tup(...)` 为 `typed_tuple_v1(...)` 的简写；`*_view`/snake_case 为 EnginePred，和 canonical PredId 的映射由 Exporter 统一且可逆实现。

---

## A. 事实审计（Data Plane）

### A1) 断言审计（Assertion Ledger）

审计对象：每条原子事实断言
载体：`claim(A, PredId, S, O)` + `meta_*`（挂 A）

用途：回答“谁在什么时候以什么来源写入了什么事实？”

例子：HR 导入 Alice 所在国家

* 写入：

  * `claim(A1, "user:country", U_alice, tup(C_de))`
  * `meta_str(A1,"trace_id","hr_import_2026_02_19")`
  * `meta_str(A1,"source","HR_DB")`
  * `meta_time(A1,"ingested_at",1771524000000000000)`
  * `meta_num(A1,"confidence",0.98)`

直观回溯查询：

* 你看到 view 里有 `user_country_view(U_alice, C_de)`
* `store.explain_fact("user:country_view",(U_alice,C_de))` 返回 `[A1]` + meta
* 你能直接读出它来自 HR_DB、哪个批次、什么时候导入

---

### A2) 撤销/失活审计（Revocation / Active State）

审计对象：断言何时被撤销、为何不再参与 view
载体：不删旧 claim；用 `active(A)` 的依据（EDB 或 IDB）+ meta 状态断言

用途：回答“为什么旧事实不再生效？”

例子：Alice 国家从 DE 改为 FR（append-only）

* 新增断言：

  * `claim(A2,"user:country",U_alice,tup(C_fr))` + meta(time=2026-03-01)
* 同时写入撤销元信息（硬规范，revokes-only）：

  - 新增撤销事件并追加 `revokes(R1, A1).`（撤销模型唯一权威见 `/Users/zhenzhili/symbolic_agent/docs/断言层 证据层.md` 的 `写入协议：Field 操作 → claim/meta/active/chosen（MVP）`；禁止 meta_bool revoked 模型）。

直观结果：

* view 只看到 FR，不看到 DE
* 审计能解释：A1 被 revoked 或被 chosen 策略淘汰

---

### A3) 冲突审计（Conflict Groups）

审计对象：同一冲突组内存在多条互斥断言
载体：SchemaIR 的 `group_key_indexes` + policy 的 chosen/active

用途：回答“有哪些冲突？当前选了谁？为什么？”

例子：functional 属性 `user:age` 冲突

* `claim(A10,"user:age",U_alice,tup(28))` meta(source=HR, time=...)
* `claim(A11,"user:age",U_alice,tup(29))` meta(source=CRM, time=...)
* 冲突组键：`(PredId="user:age", S=U_alice)`
* chosen 策略（edb 模式预计算）：选最新或按 source_priority

直观审计输出：

* `store.conflicts("user:age_view", key=(U_alice))` → 返回候选断言列表 A10/A11 与各自 meta、并给出 chosen 结果

---

### A4) View 投影审计（View Projection）

审计对象：view 事实如何由 claim + policy 得到
载体：view 规则 + chosen/active 事实（或规则）

用途：回答“view 里这条事实对应哪些断言？为什么投影出来？”

例子：`user_speaks_view(U_alice, L_de)`

* 候选断言可能有多条（来自不同规则/来源）
* view 规则：`user_speaks_view(U, L) :- claim(A, "user:speaks", U, _O), active(A), chosen(A), claim_arg(A, 0, L, _Tag).`

直观审计：

* `explain_fact("user:speaks_view",(U_alice,L_de))` → A 列表 + chosen/active 依据

---

## B. 规则与推理审计（Control Plane）

### B1) RuleAsset 版本账本（Rule Version Ledger）

审计对象：规则本身（资产）及其版本演化
载体：RuleLedger（SQLite/JSONL/表），存 `rule_ir_hash`

用途：回答“现在启用的规则版本是什么？它历史上怎么变过？”

例子：`speaks_candidate` 规则 v1 → v2

* v1：按 country.language 推 speaks
* v2：增加 preferred_language 分支（多 bodies）

RuleLedger 记录：

* `rule_id="speaks_candidate"`
* `version="1.0.0"`, `status="deprecated"`, `rule_ir_hash=...`
* `version="1.1.0"`, `status="active"`, `rule_ir_hash=...`
* `diff_note="added preferred_language branch"`

直观查询：

* `store.rules.list(active_only=True)` → 返回当前 active 版本及 hash

---

### B2) 推导运行审计（Derivation Run Log）

审计对象：一次 evaluate 的运行事件（不落库）
载体：RunLedger

用途：回答“这次跑了哪些规则版本？用的什么策略？产出了多少候选？”

例子：2026-03-02 运行 “speaks 推导”
RunLedger 记录：

* `run_id="run_20260302_001"`
* `rules=[("speaks_candidate","1.1.0")]`
* `policy_mode="edb"`, `canon_policy="error"`
* `schema_digest=...`, `edb_digest=...`, `policy_digest=...`
* `candidate_count=1532`
* `generated_at=...`

直观回溯：

* 你看到候选池里某条候选，能查到它属于哪个 run_id

---

### B3) 候选审计（Candidate Ledger）

审计对象：候选事实（未持久化）
载体：CandidateStore（stateful）

用途：回答“候选从哪里来？为什么被接受/拒绝？是否重复运行一致？”

例子：候选 `speaks(U_alice, L_de)`
Candidate 记录：

* `cand_id="cand_..."`（可选）
* `derivation_id="speaks_candidate"`, `derivation_version="1.1.0"`
* `run_id="run_20260302_001"`
* `target="user:speaks"`（或 entity type）
* `key_tuple_canonical=(U_alice, L_de)`
* `support_digest="..."`, `support_kind="exact"`（或 `approx`）
* `generated_at="..."`
* `state="new"`

直观操作：

* 用户在 UI/CLI 执行 `accept(cand_id)` 或 `reject(cand_id, reason="...")`

---

### B4) 物化审计（Materialize / Accept Log）

审计对象：一次 accept/materialize 事件
载体：MaterializeLedger

用途：回答“哪些候选被持久化？写入了哪些断言？是谁批准的？”

例子：用户批准 10 条 speaks 候选写回
MaterializeLedger：

* `materialize_id="mat_20260302_01"`
* `run_id="run_20260302_001"`
* `accepted=[cand_1..cand_10]`（或 digest）
* `written_assertions=[A200..A215]`（或 digest）
* `operator="alice_admin"`
* `id_policy="hash_v1(derivation_id,version,args)"`

直观回溯：

* 从写回的断言 meta 中能追到 `materialize_id` / `run_id`

---

### B5) Provenance 连接审计（Rule↔Fact Linkage）

审计对象：某条写回事实是由哪些规则/运行/候选产生的
载体：写回断言的 meta（桥接字段）

用途：回答“这条事实怎么来的？哪个版本推的？当时输入是什么？”

例子：写回的 speaks 断言 `claim(A300,"user:speaks",U_alice,tup(L_de))`
meta（最小推荐）：

* `meta_bool(A300,"derived",true)`
* `meta_str(A300,"derived_rule_id","speaks_candidate")`
* `meta_str(A300,"derived_rule_version","1.1.0")`
* `meta_str(A300,"run_id","run_20260302_001")`
* `meta_str(A300,"materialize_id","mat_20260302_01")`
* `meta_str(A300,"support_digest","...")`

硬约束：写回断言 meta 的 canonical key 为 `run_id`（见《断言层/证据层》保留 meta keys）；不得使用 `derived_run_id` 等别名。

直观回溯链：

* fact(A300) → run_20260302_001 → speaks_candidate@1.1.0 → schema_digest/edb_digest

---

## C. ER 审计（Entity Resolution）

### C1) canon_of 候选冲突审计

审计对象：某个 Mention 对应多个 Canonical 的候选
载体：CandidateStore 或 mapping candidates + canon_policy 执行日志

例子：

* `canon_of_candidate(M_row1, C_Alice, A20)` meta(source=HR, conf=0.8)
* `canon_of_candidate(M_row1, C_Alicia, A21)` meta(source=CRM, conf=0.9)

默认 canon_policy=error：

* evaluate 时记录冲突详情并报错（不静默）
* 错误包含：key= M_row1、候选 canonical 列表、各候选关键 meta

确定化策略（prefer_source/max_confidence/latest）：

* RunLedger 记录所用 canon_policy
* 产出 `canon_of(M_row1, C_Alicia)`（EDB）
* 并记录 tie-break 依据（建议写入 MaterializeLedger 或单独 DecisionLog）

---

### C2) bridge 审计（key_to_mention/key_to_canon）

审计对象：外部主键与 Mention/Canonical 的映射
载体：事实层（EDB）+ meta（trace/source）

例子：CSV 行号映射

* `key_to_mention(tup("csv_batch_7", 991), M_row1)` + meta(trace_id=..., source="CSV")
* typed_tuple_v1 可逆，审计可回到原始行

---

## D. Schema/Policy 配置审计（治理面）

### D1) SchemaIR 版本与摘要（Schema Digest Ledger）

审计对象：Schema 编译结果（SchemaIR）版本
载体：SchemaDigest（hash + 可选存档）

用途：回答“当时运行用的 schema 是哪一版？group_key_indexes 是什么？”

例子：

* `schema_digest="sha256:..."` 写入 RunLedger
* 可选保存 `SchemaIR` 的 JSON 快照（便于复现）

---

### D2) Policy 配置审计（Policy Digest Ledger）

审计对象：chosen/active 策略、canon_policy、policy_mode 等
载体：policy_digest 写入 RunLedger / MaterializeLedger

例子：

* `policy_mode="edb"`
* `chosen_strategy="latest_by_ingested_at_then_min_assertion_id"`
* `canon_policy="error"`
* 组合 hash → `policy_digest`

硬约束：`policy_digest` 必须等于导出包 `manifest.json` 的 `digests.policy_digest`，其计算口径以 `/Users/zhenzhili/symbolic_agent/docs/导出与运行.md` 的 `### 3.3 digest 口径（硬规范）` 为准；不允许自定义“组合 hash”。

---

## E. 导出与执行审计（引擎面）

### E1) Export Package 审计

审计对象：一次导出生成的包（facts + rules）
载体：ExportLedger

用途：回答“导出的程序是什么？用于哪个引擎？是否可重放？”

例子：

* `export_id="exp_20260302_01"`
* `target="souffle"`, `dialect_version=...`
* `facts_digest`, `rules_digest`
* `run_id` 关联

---

### E2) Engine Run 审计（可选）

审计对象：外部引擎执行结果与资源信息
载体：RunLedger 扩展字段

例子：

* 执行时长、输出行数、错误日志摘要
* 用于排查“同一输入为何不同结果”（通常是方言/版本差异）

---

## 你可以直接采用的“最小实现落点”（建议）

为了不把 EDB 搞膨胀，规则审计应独立于 claim/meta（控制面 ledger）：

* Fact（断言）审计：留在 claim/meta（你们已有）
* Rule/Run/Candidate/Materialize 审计：独立 ledger（SQLite/JSONL）
* 连接点：写回断言的 meta 中固定写 `derived_rule_id/version/run_id/materialize_id`

---

如果你愿意，我下一步可以把这份分类整理转成一个可直接落盘的 `docs/audit.md`，并补两张“链路图”：

1. 事实来源链：view → claim(A) → meta → derived_run → rule_version
2. 规则运行链：rule_version → run → candidates → materialize → new assertions
