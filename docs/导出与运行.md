# 导出与运行（Exporter/Runner）规范（MVP）

本文件定义 Exporter/Runner 的**唯一权威**导出与执行协议（MVP）。除本文件明确声明的扩展点外，任何实现不得引入“隐式降级/近似”导致跨引擎不可复现。

---

## 1. 两类包：InferencePackage vs AuditPackage

### 1.1 定义边界（硬规范）

* **InferencePackage（推理包）**：必须包含在目标引擎上独立运行所需的最小集合：Schema、（必要时）Policy、证据层 facts（claim/claim_arg/meta_* 与必要的 policy 快照）、以及可执行的 rules（view/idb/可选 policy）。目标是：Runner 在目标引擎执行后必须能产出业务谓词（view + rules outputs），且结果可由 manifest 中的 digests 校验。

* **AuditPackage（审计包）**：在 InferencePackage 的基础上，额外包含用于复现与解释的审计材料：ledger/manifest 扩展字段、导出时快照与关键中间产物引用（例如候选摘要、accept/materialize 事件、失败日志），并给出足以做一致性核验的 digest 口径。AuditPackage 的目标是：给定包内容即可离线回答“这条输出从哪来/为什么被 chosen/本次运行闭包是什么”。

硬约束：

* 推理正确性必须以 InferencePackage 为准；AuditPackage 只能“追加证据”，不得改变推理语义（不得替换 rules/facts）。
* 若同一版本既输出推理包又输出审计包，则二者的 `schema_digest/policy_digest/edb_digest/rules_digest` 必须一致；否则视为导出实现错误。

### 1.2 最小目录结构（export_v1，硬规范）

本规范锁死包的目录结构与文件名（缺失任何必需文件即为不合规包）。

**InferencePackage（推理包）目录树：**

```
<pkg_root>/
  manifest.json
  schema/
    schema_ir.json
  policy/
    policy_ir.json                 # 或 policy_rules.dl（二选一，见 manifest.policy_format）
  facts/
    claim.facts
    claim_arg.facts
    meta_str.facts
    meta_time.facts
    meta_bool.facts                # 若无 bool meta，可为空文件但必须存在（用于稳定 digest）
    revokes.facts                  # append-only 撤销模型（见证据层）
    active.facts                   # policy 快照（若 policy_mode=idb 可为空但必须存在）
    chosen.facts                   # policy 快照（若 policy_mode=idb 可为空但必须存在）
  rules/
    view.dl
    idb.dl
    policy.dl                      # 仅当 manifest.policy_mode="idb" 必须存在；否则可为空文件但必须存在
  outputs/                         # Runner 输出目录（初始可为空）
```

**AuditPackage（审计包）目录树：**

AuditPackage 必须包含完整的 InferencePackage 目录树，并额外包含：

```
<pkg_root>/
  audit/
    run_ledger.jsonl
    candidate_ledger.jsonl
    materialize_ledger.jsonl
    accept_failed.jsonl
    view_snapshot/                 # 可选：导出时 view 结果快照（用于对比，不参与推理）
```

说明：

* `schema/schema_ir.json` 的结构定义见 `/Users/zhenzhili/symbolic_agent/docs/规范.md` 的 `SchemaIR：结构（JSON Schema）与 schema_digest（硬规范）`；policy(active/chosen) 与 mapping 的语义约束见 `/Users/zhenzhili/symbolic_agent/docs/视图层.md` 的 `## 6. Policy：active / chosen（默认与约束）` 与 `## 8. Mapping（canon_of 等）视图`；本文件只规定导出位置与 digest。
* `facts/*.facts` 为**行式事实表**（见 3），用于被 Runner 加载到目标引擎。
* `rules/*.dl` 为目标方言的可执行规则文本（见 4）；Runner 必须按 `manifest.target_engine` 选择正确 dialect。
* `outputs/` 与 `run_manifest.json` 的写入规则见 6。

### 1.3 文件行格式（TSV v1，硬规范）

本规范选定事实文件格式为 **TSV（Tab-Separated Values）**，且锁死以下约束：

* 文件编码：UTF-8
* 换行：仅允许 `\n`（LF）；不得输出 `\r\n`
* 无 header；无注释行；每行末尾必须有 `\n`
* 列分隔符：`\t`（TAB）

**TSV cell escape（tsv_cell_v1，硬规范）**：用于所有“string-like”字段（例如 `PredId`、`EntityRef token`、meta 的 value、Tag 为 `string` 的 `Val`）：

* 文件中不得出现原始 TAB/LF/CR；必须用转义写入：
  - `\\` 表示反斜杠 `\`
  - `\t` 表示 TAB
  - `\n` 表示 LF
  - `\r` 表示 CR
  - 其他控制字符（U+0000..U+001F，除 TAB/LF/CR）必须写为 `\u00xx`（固定 4 位、hex 小写）
* 除上述情况外，必须直接输出 UTF-8 字符本体；禁止对非控制字符使用 `\uXXXX`（避免多种等价表示）。
* 不得做 Unicode 归一化（NFC/NFKC 等）；输入是什么就编码什么；若输入包含非法 Unicode（如孤立 surrogate），必须拒绝导出。

审计 ledger 文件格式：

* `audit/*.jsonl` 采用 JSON Lines（每行一个 JSON object，UTF-8，LF，末尾 `\n`），字段结构由各 ledger 定义；ledger 不参与推理，但参与审计复现。

---

## 2. PredId ↔ EnginePred 可逆规范化（写死算法）

本节定义将 SchemaIR/断言层里的 `PredId`（例如 `"person:country"`）规范化为目标引擎可接受的谓词名 `EnginePred` 的**可逆**算法；解释与审计一律以 `PredId` 为准。

### 2.1 normalize_pred_id(PredId) -> EnginePred（硬规范）

约束：

* `EnginePred` 必须为 ASCII 小写，满足正则：`^[a-z][a-z0-9_]*$`
* 为避免与系统保留 predicate 冲突，所有由 PredId 派生的 `EnginePred` 必须带固定前缀 `p_`。

算法（export_v1，必须完全一致）：

1) 令 `s = PredId` 的 UTF-8 bytes。

2) 输出 `EnginePred = "p_" + enc(s)`，其中 `enc` 对每个 byte `b`：

* 若 `b` 是 ASCII 小写字母 `a..z` 或数字 `0..9`：输出对应字符。
* 若 `b` 等于 `:`（0x3a）：输出单个 `_`（下划线）。  
  （这满足 “`:`→`_`” 的规范化要求）
* 其他任意 byte：输出 `__` + 两位 hex 小写（例如 `_`=0x5f → `__5f`，`-`=0x2d → `__2d`，`.`=0x2e → `__2e`，大写 `S`=0x53 → `__53`）。

反例（硬约束）：

* Exporter 不得“直接把 `-` 或 `.` 替换为 `_`”而不编码其来源；那会破坏可逆性。
* Exporter 不得丢失大小写信息：若 PredId 含大写，必须按 byte 编码保留（即输出 `__XX`）。

### 2.2 denormalize_pred(EnginePred) -> PredId（硬规范）

反向规则必须可逆恢复原始 `PredId`：

1) `EnginePred` 必须以 `p_` 开头；否则拒绝（避免把内部 head 名误当业务 PredId）。

2) 扫描 `p_` 之后的字符流：

* 遇到单个 `_`（且后续不是另一 `_`）：输出 byte `:`（0x3a）。
* 遇到 `__`：读取后续两位 hex（必须是 `[0-9a-f]{2}`），解码为一个 byte。
* 其他字符必须是 `[a-z0-9]`，输出其 ASCII byte。

3) 将 bytes 按 UTF-8 解码为 `PredId`；若 UTF-8 非法则拒绝。

### 2.3 `*_view` 别名（硬规范）

* `_view` 仅是 **EnginePred 层的别名**，不得被当作 PredId 的一部分；即 `PredId` 永远不以 `_view` 结尾。
* canonical 输出谓词名始终是 `normalize_pred_id(PredId)`；如需别名，Exporter 必须在 `rules/view.dl` 追加等价定义：
  - `EnginePred_view(...) :- EnginePred(...).`
* manifest 中的 entrypoints 必须使用 canonical `EnginePred`；`*_view` 仅供交互/UI 兼容。

---

## 3. facts 编码（与前两章对齐）

本节锁死推理包中的事实文件集合、行格式与字段顺序，并与：

* EntityRef 规则对齐（见 `/Users/zhenzhili/symbolic_agent/docs/规范.md` 的 `IdentityPolicy 与 EntityRef 生成（硬规范）`）
* `typed_tuple_v1/claim_arg` 规则对齐（见 `/Users/zhenzhili/symbolic_agent/docs/断言层 证据层.md` 的 `typed_tuple_v1 与 claim_arg：编码与 Tag 枚举（硬规范）`）
* 写入协议与撤销模型对齐（见 `/Users/zhenzhili/symbolic_agent/docs/断言层 证据层.md` 的 `写入协议：Field 操作 → claim/meta/active/chosen（MVP）`）

### 3.1 facts 文件与字段顺序（TSV，硬规范）

说明：以下 `.facts` 文件内容均为 TSV v1（见 1.3）。字段名仅用于解释；文件中无 header。

**`facts/claim.facts`**（必需）：

* 列：`Asrt` `PredId` `S` `tup_digest?`
  - `Asrt`：AssertionId（tsv_cell_v1）
  - `PredId`：业务谓词标识（tsv_cell_v1；审计以它为准）
  - `S`：canonical EntityRef token（必须是 `idref_v1:...`；禁止 pretty）
  - `tup_digest?`：可选（允许为空字符串）；推荐为 `"sha256:" + sha256_hex(typed_tuple_v1.canonical_bytes(rest_terms))`

**`facts/claim_arg.facts`**（必需，推理与审计都依赖）：

* 列：`Asrt` `Idx` `Val` `Tag`
  - `Idx`：十进制文本，0-based，连续；不允许空洞/重复
  - `Tag`：必须是 v1 枚举之一：`entity_ref|string|int|float64|bool|bytes|time|uuid`
  - `Val` 的 TSV 表示（按 Tag 写死）：
    - `entity_ref`：canonical EntityRef token（`idref_v1:...`），不得为 pretty
    - `string`：tsv_cell_v1 编码后的 UTF-8 字符串（不加引号）
    - `int`：十进制 int64（不得溢出；不得前导 `+`；除 0 外不得前导 0）
    - `float64`：固定形式 `0x` + 16 hex（表示 IEEE754 binary64 的 8 bytes big-endian）；禁止十进制浮点文本（避免非确定性解析）
    - `bool`：`true|false`（小写）
    - `bytes`：base64url no-pad（见 `typed_tuple_v1` 规范；不得 hex）
    - `time`：十进制 int64 epoch-nanos（UTC；非整纳秒输入不得被四舍五入）
    - `uuid`：小写 `8-4-4-4-12`（不得隐式纠正）

**`facts/meta_str.facts`**（必需）：

* 列：`Asrt` `Key` `Val`（均为 tsv_cell_v1）

**`facts/meta_time.facts`**（必需）：

* 列：`Asrt` `Key` `EpochNanos`（`EpochNanos` 为十进制 int64）

**`facts/meta_bool.facts`**（必需）：

* 列：`Asrt` `Key` `Bool`（`Bool` 为 `true|false`）

**`facts/revokes.facts`**（必需）：

* 列：`Asrt2` `Asrt1`（tsv_cell_v1）
* 语义：`revokes(Asrt2, Asrt1)`（撤销模型必须与证据层一致）

**`facts/active.facts` / `facts/chosen.facts`**（必需；作为 policy 快照或占位）：

* 列：`Asrt`（tsv_cell_v1）
* 语义：文件中的每行表示 `active(Asrt)` / `chosen(Asrt)` 成立。
* 约束：
  - 若 `manifest.policy_mode="edb"`：Exporter 必须输出完整快照（所有满足 active/chosen 的 Asrt 必须出现）。
  - 若 `manifest.policy_mode="idb"`：可允许为空文件，但必须存在；并且 `rules/policy.dl` 必须能在目标引擎内推出 active/chosen。

### 3.2 `typed_tuple_v1` 在文件中的表示（硬规范）

* 推理包不要求直接输出 `O=typed_tuple_v1(rest_terms)` 的结构项；**规范写法是只输出 `claim_arg` 行**，并用 `Idx/Tag/Val` 保真表达 tuple。
* `facts/claim.facts` 中的 `tup_digest`（若提供）只用于快速校验与审计；推理不得依赖它。

### 3.3 digest 口径（硬规范）

本节锁死导出 digest 的口径与输入 bytes 构造；所有 digest token 的统一格式为：

* `digest_token = "sha256:" + sha256_hex(...)`（hex 必须为小写）

* `schema_digest`：
  - `"sha256:" + sha256_hex( canonical_schema_ir_bytes )`
  - `canonical_schema_ir_bytes` 必须为 SchemaIR 的 canonical JSON bytes（推荐 RFC 8785 JCS；最少要求 key 排序、数组稳定顺序、显式版本号；见 SchemaIR 章节）。

* `policy_digest`：
  - 若 `manifest.policy_format="policy_ir_json"`：`"sha256:" + sha256_hex( canonical_policy_ir_bytes )`（同上，推荐 JCS）
  - 若 `manifest.policy_format="policy_rules_dl"`：`"sha256:" + sha256_hex( policy/policy_rules.dl bytes )`

* `edb_digest`（EDB 快照 digest）：
  - 定义 `edb_bytes` 为固定顺序拼接（必须）：
    1) `facts/claim.facts` 的 canonical bytes
    2) `facts/claim_arg.facts` 的 canonical bytes
    3) `facts/meta_str.facts` 的 canonical bytes
    4) `facts/meta_time.facts` 的 canonical bytes
    5) `facts/meta_bool.facts` 的 canonical bytes
    6) `facts/revokes.facts` 的 canonical bytes
    7) `facts/active.facts` 的 canonical bytes
    8) `facts/chosen.facts` 的 canonical bytes
  - 其中每个 facts 文件的 canonical bytes 由以下规则生成（必须）：
    - 将该文件的所有行视为“row records”，按其 **解析后的字段元组**排序（升序），再以 TSV v1 编码输出（每行末尾 `\n`）。
    - 排序键为该行各列的比较：字符串列按 UTF-8 bytes 字典序；整数列按数值；bool `false < true`。
  - 最终：`edb_digest = "sha256:" + sha256_hex( b"factpy\\x00edb_v1\\x00" + edb_bytes )`

* `rules_digest`：
  - 定义 `rules_bytes = bytes(view.dl) + bytes(idb.dl) + bytes(policy.dl)`（按固定顺序拼接）
  - `rules_digest = "sha256:" + sha256_hex( b"factpy\\x00rules_v1\\x00" + rules_bytes )`

* `support_digest`：
  - `support_digest` 是候选/写回断言的 provenance 摘要，作为 meta 写入（见证据层与 accept 协议）；包级 digest 不聚合 support_digest（避免把 UI 级解释材料绑死）。

### 3.4 引擎类型能力与拒绝规则（硬规范）

* 若目标引擎（或 Runner 目标 dialect）不支持 `claim_arg.Tag` 枚举中的某个类型，Exporter 必须在导出前拒绝（engine_capability），不得 silent stringify。
* 只有当 `/断言层 证据层.md` 的 `typed_tuple_v1 与 claim_arg` 已明确规定了该类型的“引擎侧原子化策略”且该策略不会丢失信息时，才允许导出；并且必须在 manifest 中声明（见末尾 hard constraint）。

---

## 4. rules 编码与内部 head 命名

### 4.1 view 投影与输出谓词命名（硬规范）

* 对每个业务谓词 `PredId`，其 view 输出谓词在目标引擎中的谓词名为：
  - `EnginePred = normalize_pred_id(PredId)`
* view 规则必须以 `active/chosen/claim/claim_arg/meta_*` 为输入（或等价 policy），输出 `EnginePred(...)` 业务谓词。

### 4.2 内部 head 命名规则（硬规范）

为避免与业务谓词冲突，规则编译产生的内部 head（IDB 中间谓词）必须使用保留前缀：

* `idb__<h>`：Rule/Derivation 的中间 head
* `pol__<h>`：policy 计算中间 head（若 `policy_mode="idb"`）

其中 `<h>` 取 `sha256_hex( b"factpy\\x00head_v1\\x00" + utf8(spec_key) + b\"\\x00\" + u32(clause_index) )` 的前 16 个 hex 字符（足够避免碰撞；碰撞必须拒绝导出）。

硬约束：

* 任何内部 head 名不得以 `p_` 开头（避免与业务谓词混淆）。
* 内部 head 必须满足与 EnginePred 相同的字符集约束：`^[a-z][a-z0-9_]*$`。

### 4.3 规则文件划分（硬规范）

* `rules/view.dl`：仅包含 view 投影规则（从证据层 → 业务谓词）
* `rules/idb.dl`：包含 Rule/Derivation 的推导规则（中间 head）
* `rules/policy.dl`：
  - 若 `manifest.policy_mode="idb"`：必须包含 active/chosen 的推导规则
  - 否则可为空文件但必须存在（用于稳定 digest 与 tooling 简化）

### 4.4 ProbLog 最小转换原则（MVP）

若 `manifest.target_engine="problog"`：

* Runner 必须将 `.dl` 规则转换为 ProbLog 兼容语法（核心原则：保持谓词名不变；把规则写成 `Head :- Body.`；把字符串常量写成引擎接受的 quoted atom/字符串形式）。
* 事实加载仍以 `.facts`（TSV）为准：Runner 负责把 TSV 行加载/转换为 ProbLog 可执行 facts（不得改变 `EnginePred` 名与参数顺序）。

---

## 5. manifest.json（必须给 JSON schema 级字段清单）

manifest 是包的**入口与校验根**，Runner 必须以它决定加载、执行与校验；manifest 的缺失/不一致必须视为阻塞错误。

### 5.1 必需字段清单（JSON schema 级）

以下字段为 export_v1 的最小必备（类型为约束，不是实现语言）：

* `package_kind : "inference" | "audit"`
* `protocol_version : object`
  - 必须至少包含：
    - `idref : "idref_v1"`
    - `tup  : "tup_v1"`
    - `export: "export_v1"`
* `generated_at : string`（ISO8601 UTC，纳秒精度建议；不得默认本地时区）
* `target_engine : string`（例如 `"souffle"|"problog"|...`）
* `dialect_version : string`（目标引擎/方言版本号）
* `policy_mode : "edb" | "idb"`（是否导出 active/chosen 快照）
* `policy_format : "policy_ir_json" | "policy_rules_dl"`
* `run_id? : string`（可选：若包来源于一次 evaluate/export 的运行，应填写；否则可缺省）

* `digests : object`（必须包含）
  - `schema_digest : string`
  - `policy_digest : string`
  - `edb_digest : string`
  - `rules_digest : string`
  - 约束：以上字段必须满足 `^sha256:[0-9a-f]{64}$`

* `entrypoints : object`（必须包含）
  - `output_predicates : [string]`（EnginePred 列表：Runner 必须产出这些谓词的结果）
  - `queries? : [object]`（可选：命名 query 列表；每项至少含 `id`, `predicate`, `args?`）

* `paths : object`（必须包含）
  - `schema_ir : "schema/schema_ir.json"`
  - `policy : "policy/policy_ir.json" | "policy/policy_rules.dl"`
  - `facts_dir : "facts/"`
  - `rules_dir : "rules/"`

* `provenance? : object`（可选）
  - `git_commit? : string`
  - `tool_version? : string`（Exporter/Runner 版本）

* `capability_overrides? : object`（可选；用于显式声明近似/降级；见文件末尾 hard constraint）

### 5.2 run_manifest.json（Runner 必须写）

Runner 每次执行必须在 `outputs/` 下写入 `run_manifest.json`（硬规范），至少包含：

* `engine_run_id : string`
* `source_run_id? : string`（来自 `manifest.run_id`，若存在）
* `started_at` / `finished_at`
* `exit_code : int`
* `engine_stdout? : string`、`engine_stderr? : string`（可截断，但必须标注截断）
* `outputs_digest : string`（必须为 `sha256:<hex>`；计算口径：对 outputs/ 下所有输出文件按固定顺序拼接 bytes 后取 sha256；细则可与 `rules_digest` 类似）
  - 硬约束：`outputs_digest` 只覆盖 `outputs/*.out.facts`，按相对路径 UTF-8 字典序拼接其 bytes 计算；不得包含 `outputs/run_manifest.json`。
* `status : "ok" | "failed"`

---

## 6. Runner 执行协议

### 6.1 Runner 输入/输出（硬规范）

**输入：**

* `package_path`：包根目录（含 manifest.json）
* `entrypoint`：来自 `manifest.entrypoints` 的选择（例如输出某些 `output_predicates`，或执行某个 `query id`）
* `options`（最小必须支持）：
  - `timeout_ms?`
  - `max_answers?`（若引擎支持）
  - `dry_run?`（只校验 digests 与可加载性，不实际执行推理）

**输出：**

* 所有输出必须写入 `<pkg_root>/outputs/`（不得写到包外）
* 必须写 `outputs/run_manifest.json`（见 5.2）
* 业务谓词输出必须以 TSV v1 写入（建议按 predicate 分文件）：
  - `outputs/<EnginePred>.out.facts`（每行是一条 fact；字段顺序与 view 谓词参数顺序一致）

硬约束（MVP，必须）：Runner 写出 `outputs/<EnginePred>.out.facts` 前必须对输出行按“解析后的字段元组”做稳定升序排序（排序规则同本文件 3.3 `edb_digest` 的 row 排序规则）；不得依赖引擎原始输出顺序。
并且 `outputs_digest` 必须基于排序后输出文件的 bytes 计算；否则视为实现错误。

### 6.2 错误与重跑语义（硬规范）

* Runner 在执行前必须校验：
  - manifest 必需字段存在且类型正确
  - `schema_digest/policy_digest/edb_digest/rules_digest` 与包内容匹配
  - `protocol_version` 与 Runner 支持的版本兼容（不兼容必须拒绝）
  - 硬约束：Runner 必须按 `claim_arg.Tag` 解码 TSV 的 `Val` 并以对应原子域加载；不支持的类型必须拒绝（禁止静默 stringify）。特别地，`float64` 的 `0x<16hex>` 必须按位解码为 IEEE754 binary64，否则必须拒绝（engine_capability）。
* 若校验失败：必须写 `run_manifest.json(status="failed")`，并包含错误摘要；不得输出任何业务谓词结果。
* 重跑确定性（硬约束）：
  - 对同一 `manifest + facts + rules + options + target_engine@dialect_version`，Runner 输出必须 deterministic；否则 Runner 必须报错并在审计包（若存在 `audit/`）写入不可确定性记录。

### 6.3 run_id 关系（硬规范）

* `manifest.run_id`（若存在）表示“上游 evaluate/export 的 source run”；它用于与 CandidateSet/accept 审计关联。
* `engine_run_id` 表示“Runner 在目标引擎的执行实例”；它可以与 `manifest.run_id` 不同，但必须可关联：
  - 必须在 `outputs/run_manifest.json` 同时记录 `engine_run_id` 与 `source_run_id?`；
  - 如需把关联写回到 EDB/断言 meta，必须使用独立保留 key（例如 `meta_str(Asrt,"engine_run_id",...)`），且不得覆盖任何保留 key（见证据层 meta 规范）。

---

## 7. 最小示例（1 个）

以下示例展示一个最小 inference package（仅示关键文件），并展示 PredId/EnginePred 映射与 TSV 行样例。

### 7.1 目录树

```
pkg_min/
  manifest.json
  schema/schema_ir.json
  policy/policy_ir.json
  facts/claim.facts
  facts/claim_arg.facts
  facts/meta_str.facts
  facts/meta_time.facts
  facts/meta_bool.facts
  facts/revokes.facts
  facts/active.facts
  facts/chosen.facts
  rules/view.dl
  rules/idb.dl
  rules/policy.dl
  outputs/
```

### 7.2 manifest.json 片段（≤25 行）

```json
{
  "package_kind": "inference",
  "protocol_version": {"idref":"idref_v1","tup":"tup_v1","export":"export_v1"},
  "generated_at": "2026-03-02T10:11:12.123456789Z",
  "target_engine": "souffle",
  "dialect_version": "v2",
  "policy_mode": "edb",
  "policy_format": "policy_ir_json",
  "run_id": "run_20260302_001",
  "digests": {
    "schema_digest": "sha256:...",
    "policy_digest": "sha256:...",
    "edb_digest": "sha256:...",
    "rules_digest": "sha256:..."
  },
  "entrypoints": {"output_predicates": ["p_person_country"]},
  "paths": {"schema_ir":"schema/schema_ir.json","policy":"policy/policy_ir.json","facts_dir":"facts/","rules_dir":"rules/"}
}
```

### 7.3 映射与 facts 示例行（TSV）

* PredId → EnginePred：
  - `PredId="person:country"` → `EnginePred="p_person_country"`

`facts/claim.facts`（一行示例；列顺序：Asrt, PredId, S, tup_digest?）：

```
A300	person:country	idref_v1:Person:abcd...	sha256:deadbeef...
```

`facts/claim_arg.facts`（三行示例；列顺序：Asrt, Idx, Val, Tag）：

```
A300	0	idref_v1:Country:ef01...	entity_ref
```

（对应 view 输出谓词 `p_person_country(E, CountryE)` 的 `EnginePred` 名为 `p_person_country`；Runner 应在 `outputs/p_person_country.out.facts` 写出 `E\tCountryE\n` 形式的结果行。）

---

最终硬约束：`Exporter/Runner` 的任何近似/降级必须在 manifest 里显式声明（例如 `lossy=true` 或 `capability_overrides` 中列明哪些 Tag 被降级及其规则），否则视为实现错误。
