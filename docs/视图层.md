
# View 层规范（业务谓词投影层）

## 1. 定义与目标

View 层是一组“推理默认使用的业务谓词”，由证据层（claim/meta）在给定 policy（active/chosen/current）下投影得到。View 层满足：

- 人类友好：不暴露 AssertionId、tup1 token、meta 结构。
    
- 规则友好：可直接写 Horn/Datalog 子句。
    
- 语义稳定：当前事实由 policy 决定（active/chosen/current），而非物理覆盖。
    

硬约束：

- 用户规则默认只引用 `*_view`（或导出为业务谓词名本身），不得直接引用 `claim/meta_*`，除非 `audit_mode=True`。
    
- 第一个参数固定为实体锚点（EntityRef），在规范中记为 `E`。
    

---

## 2. 证据层与视图层的关系

证据层（append-only ledger）包含：

- `claim(A, PredId, E, O)`：原始断言载体（唯一写入点）
    
- `meta_*`：断言元数据（挂在 A 上）
    
- `active(A)`：断言是否参与视图
    
- `chosen(A)`：冲突组中被选中的断言
    
- `claim_arg(A, idx, val, tag)`：对 `O=typed_tuple_v1(rest_terms)` 的索引解包表
    

视图层（推理 API）包含：

- 业务谓词 `p(...)`：由 claim + policy 投影出的“当前事实”
    
- （可选）temporal 的 `*_record_view` 与 `*_current_view`
    
- （可选）mapping 的 `*_candidate_view` 与 `*_view`（生效映射）
    

---

## 3. 命名规范（关键）

### 3.1 base predicate 的“业务名”如何确定

对 schema 中的每个 Field，定义其业务谓词名 `p`：

1. 若 Field 显式指定 `Field(name="has_age")`，则 `p = "<owner>:has_age"`（或你们已有命名空间规则）。
    
2. 否则使用默认名：`p = "<owner>:<field_name>"`。
    
`Field(name=...)` 只改变“业务谓词名”（predicate id），不改变 Python 层字段名；Python 层仍然用 `person.age` 访问，底层写入的 PredId 可能是 `person:has_age`。
说明：此处的 `p` 是“业务谓词名”，不是 `claim` 中的 `PredId` 的展示方式；但实际实现里通常二者一致（PredId 直接用 `p` 字符串）。

### 3.2 view predicate 的命名策略

view 谓词默认 = 业务谓词名本身；如需兼容导出，可额外提供 `*_view` 作为同义别名（两者必须等价）。

硬约束：Exporter 必须提供 PredId→EnginePred 的可逆规范化（例如将 `:` 规范化为 `_`），解释/审计一律以 PredId 为准。

- 推理引擎只看到干净的业务谓词 `person:has_age(E, Age)`
    
- claim/policy 仅作为底层实现细节，可不导出到推理包（或仅审计包导出）

---

## 5. View 生成模板（普通谓词）

### 5.1 业务谓词形态

对每个 `p`（非 temporal/mapping），view 业务谓词形态为：

- `p(E, A1, A2, ..., A{N-1})`
    

其中：

- `E` 固定是实体锚点（EntityRef）
    
- `A1..A{N-1}` 的参数名来自 SchemaIR.arg_specs[i].name（例如 `age`、`lang`、`company`）
    
### 5.1.2 view 参数命名来源

view 谓词的第一个参数固定为实体锚点（EntityRef），文档统一记为 `E`。

其余参数名来自 SchemaIR 的 `arg_specs[i].name`，生成规则如下：

A) 经典二元字段（E → value）

- `p(E, Value)`
    
- `Value` 的参数名默认取 Python 字段名的 PascalCase（如 `age → Age`），或按你们内部规范生成。
    
- 若 Field 使用 `name="has_age"`，参数名仍建议保持与语义一致（`Age`），不必从 `has_age` 推导。
    

B) 实体引用字段（E → E2）

- `p(E, Target)`
    
- 参数名默认取字段名的 PascalCase（如 `works_at → Company` 或 `WorksAt`）。
    

C) n-ary / dims 字段（E + dims → value）

- `p(E, Dim1, Dim2, ..., Value)`
    
- dims 参数名来自 `fact_key` 中声明的维度名（见 3.2），Value 同 A。

### 5.2 投影规则模板（概念）

对任意 `p`：

- `p(E, A1, ..., A{N-1}) :-`
    
    - `claim(Asrt, PredId, E, _O),`
        
    - `active(Asrt), chosen(Asrt),`
        
    - 对每个 `i in 1..N-1`：
        
        - `claim_arg(Asrt, i-1, Ai, Tag_i).`
            

约束：

- `Tag_i` 必须与 `arg_specs[i].type_domain` 对齐。
    
- builtin（比较、算术）只允许作用于 value 域变量（例如 `Age`, `Year`），不允许对 entity_ref 变量比较。
    

---

## 6. Policy：active / chosen（默认与约束）

### 6.1 active(A)

语义：断言是否参与当前视图。默认策略：

- 若无撤销/失效机制：`active(A)` 对所有断言为真。
    
- 若启用撤销：由 meta 或专门谓词决定（例如 `meta_bool(A,"active",false)` 则过滤）。
    

实现建议：

- `policy_mode="edb"`：Python 预计算并导出 `active.csv` / facts。
    
- `policy_mode="idb"`：可导出规则定义，但必须保证确定性与方言可表达。

硬约束（MVP，必须）：`active(A)` 的语义仅由证据层“撤销模型 `revokes/2`”决定（见 `/Users/zhenzhili/symbolic_agent/docs/断言层 证据层.md` 的 `写入协议：Field 操作 → claim/meta/active/chosen（MVP）`）；禁止以 `meta_bool(A,"active",false)` 等 meta 模型替代。
    

### 6.2 chosen(A)

语义：在同一冲突组内选择“代表断言”。

冲突组 key 定义（硬约束）：

- `K(A) = (PredId, E, dims...)`
    
- dims 来自 `group_key_indexes` 指定的参数位置（不含 subject=0）
    

不同 cardinality 的默认行为：

1. `multi`：
    

- 默认 `chosen(A)=true`（所有 active 的断言均被选中）
    

2. `functional`：
    

- 对每个冲突组 `K`，必须恰好选择一个 `A*` 为 chosen
    
- 默认 tie-break 必须写死并确定性，例如：
    
    - 优先 meta.ingested_at 最大
        
    - 再用 AssertionId（或写入序号）做稳定兜底
        

3. `temporal`：见第 7 节（current 由策略定义）
    

重要：如果目标引擎缺乏稳定 tie-break 所需的聚合/排序能力，则必须：

- 强制 `policy_mode="edb"`，由 Python 预计算 chosen
    
- 或显式拒绝（你们对 mapping 已这样处理）

硬约束（MVP 默认 chosen_strategy）：functional 冲突组的 chosen 选择规则锁死为 `latest_by_ingested_at_then_min_assertion_id`：选 `meta_time(ingested_at)` 最大的 active 断言；若并列，选 AssertionId 按 UTF-8 字典序最小者。
若该冲突组任一候选缺失 `ingested_at` 或其类型不合法，则必须拒绝（policy_non_determinism），不得降级为不稳定选择。
    

---

## 7. Temporal 视图（valid_time / versioned）

temporal 字段在证据层以 reified 记录写入（多条 role 谓词）。view 层建议固定提供两类谓词：

### 7.1 record view（全量历史）

例（valid_time）：

- `person:salary_record(R, E, value, start, end, dims...)`
    

例（versioned）：

- `person:level_record(R, E, value, version, current_flag, dims...)`
    

其中 `R` 是 temporal 记录实体锚点（EntityRef），`E` 是 owner。

### 7.2 current view（当前值）

例（valid_time）：

- `person:salary_current(E, value, now, dims...)`
    

例（versioned）：

- `person:level_current(E, value, dims...)`
    

约束：

- current 永远是 view 语义，不允许通过覆盖历史事实实现。
    
- 若引擎不支持 current 所需的聚合/排序，Python 预计算 current 并导出 EDB。
    

---

## 8. Mapping（canon_of 等）视图

mapping 谓词必须满足：

- 单值（functional）
    
- 确定性（tie-break 稳定）
    
- 不允许不稳定多解静默通过（默认 mode=error）
    

建议输出：

1. 生效映射（业务默认用）
    

- `canon_of(MentionE, CanonE)`
    

2. 候选映射（审计可选）
    

- `canon_of_candidate(MentionE, CanonE, Asrt)`（其中 Asrt 是证据断言编号，用于解释）
    

实现边界：

- `policy_mode="edb"`：Python `CanonPolicyResolver` 选出唯一映射，导出为 EDB facts
    
- `policy_mode="idb"`：需要聚合/排序时必须拒绝或要求引擎能力显式满足
    

---

## 9. 单一 Datalog 引擎的简化运行包（推荐写进文档）

如果只支持一个引擎，并且目标是“推理包尽可能干净”，推荐：

- 证据层（claim/meta/arg/active/chosen）存数据库/Parquet/CSV，用于审计与重算
    
- 导出推理包时，只导出“业务 EDB 快照 + 用户 rules”：
    
    - 业务 EDB = view 计算结果（直接用业务谓词名 `p(...)`）
        
    - 用户 rules 直接引用业务谓词名（无需 `_view`）
        

效果：

- 推理侧完全是传统 Datalog：EDB facts + IDB rules
    
- 更换 policy/ER 策略时，重新从证据层重算 view 并重新导出即可
    

---

## 10. 变量命名约定（文档统一）

为避免读者把 `S` 误解为“字符串”，本规范统一使用：

- `E`：实体锚点（EntityRef），永远是第一个参数
    
- `Asrt`：断言编号（AssertionId）
    
- `PredId`：谓词标识
    
- `A1..`：其余参数，名称优先使用 schema arg name（如 `Age`、`Lang`、`Company`）
    





