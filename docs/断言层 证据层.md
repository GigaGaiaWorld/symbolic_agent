# 断言层/证据层
## claim（断言载体）

`claim/4` 是系统中唯一的“业务断言写入点”。所有字段写入（set/add/remove）、桥接（key_to_mention 等）、以及将来可能的撤销/状态断言，最终都落成一条 `claim`。

形式：

- `claim(A, PredId, S, O).`
    

参数语义：

- `A`：AssertionId（断言编号，UUID 或可重放 ID）。  
    用途：挂 meta、参与 chosen/active、溯源解释的最小单位。
    
- `PredId`：谓词标识（当前实现可为字符串，如 `"person:name"`；也可映射为 int）。  
    用途：区分“这条断言属于哪个字段/关系/桥接谓词”；冲突组与 view 投影都以 PredId 为核心索引。
    
- `S`：Subject（主实体 EntityRef）。  
    当前默认约束：`S` 固定为“主实体引用”，其位置由 `subject_position=0` 锁死。  
    用途：将断言归属到某个实体节点，成为 join 的主键。
    
- `O`：Object（规范化后的“剩余参数”）。  
    当前默认约束：`O = typed_tuple_v1(rest_terms)`，其中 `rest_terms` 是除 `S` 外的全部参数，按 SchemaIR 的参数顺序编码。  
    用途：支持高元事实、支持跨方言一致性与可逆解码。
    

注意：

- 在 claim 层，系统不会直接存 `person_name(P,"Alice")` 这种“业务谓词事实”；业务谓词由 view 层投影得到。
    
- claim 是 append-only：同一 PredId/S/O 可以出现多条 claim（不同 A），是否“合并/选择”由 chosen/active 处理。
    

## 写入协议：Field 操作 → claim/meta/active/chosen（MVP）

本节定义“字段操作 → 证据层写入”的**最小可实现写入合约**。所有写入最终都表现为追加（append-only）的证据层 facts；禁止就地更新或覆盖既有 facts。

### 1) 写入接口面（抽象 API）

本协议定义四类逻辑操作（接口语义规范，不要求具体语言 API）：

- `set_field(E, PredId, dims..., value, meta)`
    
    - 用途：`cardinality=functional|temporal` 的写入入口（**新增**断言，不覆盖历史）。
        

- `add_field(E, PredId, dims..., value, meta)`
    
    - 用途：`cardinality=multi` 的写入入口（**新增**断言，允许并存）。
        

- `retract(Asrt | (E, PredId, dims..., value?), meta)`
    
    - 用途：撤销/删除（在 append-only 下只能通过新增“撤销事件”表达）。
        
    - `value?` 为可选：若省略 value，则仅允许用于 functional 冲突组的“撤销当前 chosen”；否则必须拒绝（见 2）。
        

- `replace_field(E, PredId, dims..., new_value, meta)`
    
    - 语义：**等价于** `retract(old) + set_field(new)`，必须写死为两步追加写入，且不得引入第三种“覆盖写”。
        
    - `old` 的解析规则见 `retract(...)`（functional 默认撤销当前 chosen）。
        

写入落地（硬约束，必须）：

- 所有 `set_field/add_field/replace_field` 都必须追加写入一条业务断言：
    
    - `claim(Asrt, PredId, E, O).`
        
    - `O = typed_tuple_v1(rest_terms)`，其中 `rest_terms` 为除 subject 外的参数（包含 dims 与 value），顺序必须与 SchemaIR.arg_specs 对齐（见本文件 `typed_tuple_v1 与 claim_arg：编码与 Tag 枚举（硬规范）`）。
        
- `meta` 只追加写入到 `meta_*`；不得以“更新”方式改写既有 meta。
    
- `active/chosen` 是 policy 接口：写入协议只能通过“新增证据/撤销事件”影响它们的结果，不得直接覆盖它们的语义。
    

### 2) append-only 下的“撤销/删除唯一模型”（硬规范，已选定）

本系统 **选择模型 A（显式撤销断言）**，并锁死为唯一模型：

- 新增撤销关系事实：
    
    - `revokes(Asrt2, Asrt1).`
        
    - 语义：断言 `Asrt2` 撤销（revoke）断言 `Asrt1`。
        
    - `Asrt2` 是一次撤销事件的 AssertionId；撤销事件同样可以挂 meta（用于审计）。
        

`active(A)` 的默认语义（硬约束，必须）：

- 对任意断言 `A`，当且仅当不存在一个**处于 active 状态的撤销事件** `R` 使得 `revokes(R, A)`，则 `A` 为 active。
    
- 撤销事件本身也是断言，因此允许“链式撤销”：
    
    - 若 `revokes(R1, A)` 且 `R1` active，则 `A` inactive。
        
    - 若进一步 `revokes(R2, R1)` 且 `R2` active，则 `R1` inactive，从而 `A` 恢复为 active（除非还有其他 active 的撤销事件覆盖 `A`）。
        
- `revokes` 图出现环（cycle）一律拒绝写入（否则 active 语义不再可判定）。
    

撤销的幂等性与可审计性（硬约束，必须）：

- 当目标 `Asrt1` 当前为 active 时，执行 `retract(Asrt1, ...)` 必须新增一个撤销事件 `Asrt2` 并追加 `revokes(Asrt2, Asrt1)`。

- 当目标 `Asrt1` 已被某个 **active** 的撤销事件覆盖时，重复执行 `retract(Asrt1, ...)` 必须幂等（no-op）：不得追加新的撤销事件与 `revokes` 边，必须返回该撤销事件 `Asrt2`。

- 撤销事件 `Asrt2` 必须写入本节第 5 条规定的保留 meta keys（至少 `ingested_at/source/trace_id/schema_digest/policy_digest`），以保证可审计性。

`retract(...)` 的解析规则（硬约束，必须）：

- `retract(Asrt1, meta)`：撤销指定断言 `Asrt1`（落地为上文 `revokes(Asrt2, Asrt1)`）。
    
- `retract((E, PredId, dims..., value), meta)`：必须先用**精确匹配**解析到唯一的 `Asrt1`（即存在且仅存在一条 `claim(Asrt1, PredId, E, typed_tuple_v1(rest_terms))` 与该 `(dims...,value)` 对齐）；解析不到或出现多条匹配必须拒绝。
    
- `retract((E, PredId, dims...), meta)`（省略 value）：仅允许用于 `cardinality=functional`，且必须解析到该冲突组下唯一的 active+chosen 断言 `Asrt1`；否则必须拒绝。
    

### 3) 幂等与去重键（硬规范）

本系统定义两条独立的幂等策略：导入幂等（ingest）与 accept 幂等（materialize）。

#### 3.1 导入/FactCompiler 写入的幂等：`ingest_key`

定义 `ingest_key`（硬规范，必须可复现）：

- `ingest_key = sha256_hex(ingest_key_bytes)`
    
- `ingest_key_bytes` 的构造（确定性）：
    
```text
ingest_key_bytes :=
    b"factpy\x00ingest_v1\x00"
 || u32be(len(PredId_utf8)) || PredId_utf8
 || u32be(len(E_utf8))      || E_utf8
 || u32be(len(tup_bytes))   || tup_bytes                 # tup_bytes = canonical_bytes(rest_terms)，见 typed_tuple_v1 章节
 || u32be(len(source_utf8)) || source_utf8
 || u32be(len(source_loc_utf8)) || source_loc_utf8
```

其中：

- `source`：导入源（如 `"HR"` / `"CRM"` / `"csv"`），写入 `meta_str(Asrt,"source",...)`。
    
- `source_loc`：导入定位符（如 `"employee.csv#row=991"` / `"hr_api:user_id=123"`），用于幂等去重；写入 `meta_str(Asrt,"source_loc",...)`。
    

落地规则（硬约束，必须）：

- 每条导入产生的 `claim(Asrt,...)` 必须同时写入 `meta_str(Asrt,"ingest_key",<sha256_hex>)`。
    
- 若发现同一 `ingest_key` 已存在（不论 active 与否），新的导入写入必须被视为 duplicate 并 **no-op**：不得追加新的 `claim`；必须返回既有 `Asrt`（可返回 `status="duplicate"` 供上层审计）。
    

#### 3.2 Derivation.accept 写入的幂等：`materialize_id + cand_key`

定义 accept 幂等键（硬规范）：

- accept 的幂等域为 `(materialize_id, cand_key)`：
    
    - `materialize_id`：一次 accept 事务/批次的唯一标识。
        
    - `cand_key`：来自 CandidateSet 的去重键（见 `CandidateSet 最小输出契约`），默认：
        
        - `cand_key = (derivation_id, derivation_version, target, key_tuple_canonical)`
            

落地规则（硬约束，必须）：

- accept 写回的每条新断言必须写入 `meta_str(Asrt,"materialize_id",...)` 与 `meta_str(Asrt,"cand_key",...)`（`cand_key` 文本必须是可复现的 canonical 形式；若无法稳定表示，必须改为 `sha256_hex(cand_key_bytes)` 并写入 `cand_key_digest`）。
    
- 对同一 `(materialize_id, cand_key)` 的重复 accept 必须 **no-op**：不得追加新的 `claim`；必须只返回已存在的 `Asrt` 列表/摘要。
    

硬约束：幂等检查必须以 `(materialize_id, cand_key_digest)` 为准，其中 `cand_key_digest` 的构造必须包含 CandidateSet.key_tuple_digest（`sha256:<64hex>`）。
`key_tuple_canonical` 仅用于展示，不得作为任何 digest/幂等键输入。

### 4) claim / claim_arg 的生成时机（硬规范）

本系统允许两种策略，但必须明确默认策略；不允许混用导致语义漂移。

- 默认策略（MVP）：**EDB 端物化 `claim_arg`**
    
    - `claim` 写入时或导出时必须生成对应的 `claim_arg` 行（可存储为事实表或在导出包阶段生成）。
        
    - 引擎侧无需解包 `O` 即可 join/filter。
        

- 可选策略：引擎内规则解包 `O`
    
    - 允许用引擎内规则从 `claim(Asrt,_,_,O)` 解包生成 `claim_arg`；
        
    - 但必须保证与本文件 `typed_tuple_v1 与 claim_arg：编码与 Tag 枚举（硬规范）` 完全一致的 `Idx/Tag/Val` 语义。
        

无论采用哪种策略，`claim_arg` 必须满足：

- `Idx` 0-based 且连续、无缺洞/重复；
    
- `Tag/Val` 必须与 `typed_tuple_v1` 的 canonicalization 一致；
    

### 5) meta keys 最小保留集合（硬规范）

meta key 命名空间规则（硬约束）：

- 保留 key（reserved）拥有固定语义与类型；一旦写入不得被覆盖、不得删除、不得改类型（同一 `Asrt` 下对同一 reserved key 重复写入或给出不同值必须拒绝）。

- 允许用户自定义 key，但不得与 reserved key 同名；冲突必须拒绝。
    

每条新增断言（包括业务断言与撤销事件）必须写入的最小 meta（reserved，必写）：

- `ingested_at`：time（必须 timezone-aware；规范到 UTC；精确到纳秒；**必须**写为 `meta_time(A,"ingested_at",EpochNanos)`，其中 `EpochNanos` 为 UTC epoch-nanos int64；禁止用 `meta_str` 的 ISO8601 形式）。
    
- `source`：string
    
- `trace_id`：string（用于导入链路追踪；**可与** `run_id` 不同）
    
- `schema_digest`：string
    
- `policy_digest`：string
    

导入幂等相关（reserved，必写）：

- `ingest_key`：string（sha256_hex）
    
- `source_loc`：string（用于构造 ingest_key；见 3.1）
    

accept 写回相关（reserved，按场景必写）：

- `derived_rule_id`：string
    
- `derived_rule_version`：string
    
- `run_id`：string
    
- `materialize_id`：string
    
- `cand_key`：string（canonical）或 `cand_key_digest`：string（sha256_hex；用于幂等/去重）
    
- `support_digest`：string
    
- `approved_by`：string（可选）
    

### 6) 与 SchemaIR.cardinality/fact_key 的交互规则（硬约束）

- functional（`cardinality=functional`）
    
    - 同一冲突组（`E + dims`）允许存在多条 `claim`；view/current 只能 `chosen` 一条。
        
    - `set_field` 不做覆盖：只新增 `claim`；冲突交由 policy（`active/chosen`）确定化。
        
    - 若业务语义要求“把旧值明确作废”，必须用 `replace_field`（即 `retract(old) + set_field(new)`）。
        

- multi（`cardinality=multi`）
    
    - `add_field` 允许多条并存；不得用 `set_field` 试图覆盖（必须拒绝）。
        
    - `chosen` 对 multi 的默认语义固定为“全真”（所有 active 的断言均视为 chosen）；允许实现不显式物化 `chosen/1`，但 view 语义必须等价。
        

- temporal（`cardinality=temporal`）
    
    - 每次 `set_field/add_field` 都必须追加写入（append-only）；不允许“回写覆盖历史”。
        
    - current 只能由 temporal policy/view 推导；不得通过写入协议实现“更新当前值”的覆盖语义。
        

### 7) 最小示例（必须）

示例 1（functional：连续两次 set_field，不覆盖，只追加）：

设 `PredId="person:country"`，并假设 value 域为 `entity_ref`。

1) 第一次写入：

- `set_field(E, "person:country", C_de, meta={source="HR", trace_id="hr_import_2026_02_19", ...})`
    
- 追加：
    
    - `claim(A1, "person:country", E, typed_tuple_v1([C_de])).`
        
    - `meta_time(A1,"ingested_at",T1).`
        
    - `meta_str(A1,"source","HR").`
        
    - `meta_str(A1,"trace_id","hr_import_2026_02_19").`
        
    - `meta_str(A1,"schema_digest",SchemaD). meta_str(A1,"policy_digest",PolicyD).`
        
    - `meta_str(A1,"ingest_key",K1). meta_str(A1,"source_loc",Loc1).`
        

2) 第二次写入（不同值）：

- `set_field(E, "person:country", C_fr, meta={source="HR", trace_id="hr_import_2026_03_01", ...})`
    
- 追加：
    
    - `claim(A2, "person:country", E, typed_tuple_v1([C_fr])).` + meta（同上）
        

结果语义：

- 两条 claim 都存在且默认 active。
    
- 在 functional 冲突组下，policy 需确定 `chosen(A)`；例如若 chosen 选 `A2`，则 view 中表现为 `person:country(E, C_fr)`。
    

示例 2（retract：撤销其中一条断言）：

撤销 `A1`：

- `retract(A1, meta={source="admin", trace_id="manual_fix_001", ...})`
    
- 追加：
    
    - `revokes(R1, A1).`
        
    - `meta_time(R1,"ingested_at",T2).`
        
    - `meta_str(R1,"source","admin"). meta_str(R1,"trace_id","manual_fix_001").`
        
    - `meta_str(R1,"schema_digest",SchemaD). meta_str(R1,"policy_digest",PolicyD).`
        

结果语义：

- 因存在 active 的撤销事件 `R1` 覆盖 `A1`，所以 `A1` 变为 inactive；`A2` 不受影响。
    
- view/chosen 的确定化在 `A1` 不再 active 后只会在剩余 active 断言上发生。
    

最终约束：`accept` 写回协议（见 `/Users/zhenzhili/symbolic_agent/docs/规则.md` 的 `accept 写回协议（MVP）与 Store API（最小合约）`）必须复用本节的撤销模型与幂等键策略，禁止另起一套。

---

## PredId（谓词标识）

PredId 的来源：

- 由 SchemaCompiler 为每个 Field（含角色谓词、temporal 展开谓词、bridge 谓词）生成。
    
- LLM 或外部输入不得自由发明 PredId；所有 PredId 必须命中 SchemaIR 注册表。
    

命名建议（当前约定）：

- 属性：`person:age`、`company:sector`
    
- 边：`person:works_at`
    
- reified 角色：`employment:employee`、`employment:employer`
    
- temporal 展开：`person:salary:value`、`person:salary:start`、`person:salary:end`
    
- ER bridge：`er:key_to_mention`、`er:key_to_canon`
    

---

## S（EntityRef）

EntityRef 是逻辑引擎里使用的“实体常量符号”，由 IdentityPolicy 的确定性序列化与哈希得到。

关键约束：

- EntityRef 只由 Identity 字段决定，与 Field 值、meta 完全解耦。
    
- EntityRef 的可读性不重要；重要的是跨运行稳定与不会因属性更新而变化。
    
- 展示层建议做“带类型前缀”的 pretty 形式（例如 `Person__<hex>`），但这不应影响内部语义。
    

---

## O（typed_tuple_v1）

`typed_tuple_v1` 是多元参数的规范化容器，保证：

- 可逆：可以 decode 回 term 列表
    
- 确定性：相同输入得到相同 token
    
- 类型标注：每个 term 带 `tag`（string/int/entity_ref/...）
    

编码策略（当前默认）：

- `S = 主实体 EntityRef`
    
- `O = typed_tuple_v1(rest_terms)`
    
- `rest_terms` 的顺序必须与 SchemaIR 中该 Pred 的参数顺序一致
    

为什么要把剩余参数打包进 O：

- 统一到 `claim/4`，让“断言”始终是固定 arity（便于存储、审计、跨方言导出）
    
- 避免某些引擎对 tuple/n-ary 支持差异
    
- 为 claim_arg 解包与索引提供统一入口
    

---

## typed_tuple_v1 与 claim_arg：编码与 Tag 枚举（硬规范）

本节定义 `typed_tuple_v1` 与 `claim_arg` 的**跨引擎可移植**编码与类型标注规则。除本节明示规则外，任何实现不得依赖“运行时类型推断”来解释 tuple 内部值。

### 1) 规范对象与不变量

定义：

- `typed_tuple_v1(rest_terms)`：`claim/4` 的 `O` 字段**唯一规范容器**。
    
- `claim_arg(Asrt, Idx, Val, Tag)`：对同一 `Asrt` 的 `typed_tuple_v1(rest_terms)` 的**行式解包索引**（Idx → 值）。
    

不变量（硬约束，必须）：

- `rest_terms` 的顺序来自 SchemaIR 的参数顺序（即 `claim(S, ...)` 中除 subject 外的其余参数，按 SchemaIR.arg_specs 的顺序），不得重排。
    
- 对同一 `Asrt`，`claim_arg` 必须**完整覆盖** `rest_terms`：对每个 `Idx∈[0..N-1]` 恰好存在一行 `claim_arg(Asrt, Idx, _, _)`，且：
    
    - `Idx` **0-based** 且连续（禁止缺洞）
        
    - 禁止重复 Idx
        
- `Tag` 是**类型标签**，决定 `Val` 的解释；不得靠 Prolog/Datalog 的运行时类型推断替代 `Tag`（例如不能因为 `Val` 是数字就假定它是 int）。
    

### 2) Tag 枚举全集（v1）与语义（锁死）

`Tag` 的取值（v1）锁死为下述集合；任何新增必须升级为新版本（例如 `tup_v2`）：

- `entity_ref`
    
    - 语义：实体引用（EntityRef）。
        
    - `Val` 必须是 canonical EntityRef token 字符串（形如 `idref_v1:<entity_type>:<digest_b32>`）。
        
    - 必须符合 `/Users/zhenzhili/symbolic_agent/docs/规范.md` 的 `IdentityPolicy 与 EntityRef 生成（硬规范）`；禁止 pretty-display。
        

- `string`
    
    - 语义：UTF-8 字符串（不做 trim/NFC/NFKC/casefold 等任何归一）。
        

- `int`
    
    - 语义：有符号 64-bit 整数（`[-2^63, 2^63-1]`）。
        
    - 若输入来自十进制文本，必须解析为**精确 int64**；否则报错（不得取整、不得转 float）。
        

- `float64`
    
    - 语义：IEEE754 binary64（double）。
        
    - 仅允许有限值；`NaN/+Inf/-Inf` 一律报错；`-0.0` 必须 canonicalize 为 `+0.0`。
        
    - 若输入来自十进制文本（例如 JSON 数字/字符串），解析必须是**正确舍入（round-to-nearest, ties-to-even）**到 binary64；实现无法保证正确舍入时，必须拒绝该输入域（不得“差不多”）。
        
    - 建议：IdentityPolicy 尽量禁用 float 作为 identity；但在普通 Field value 域允许 `float64`。
        

- `bool`
    
    - 语义：布尔值（仅 `true/false`）。
        

- `bytes`
    
    - 语义：原始字节序列。
        
    - v1 的 `Val` 文本表示采用 **base64url（RFC4648 URL-safe）且 no-pad**（禁止 `=` padding）。
        

- `time`
    
    - 语义：绝对时间点（instant）。
        
    - 必须 timezone-aware；规范化到 UTC；以 **Unix epoch-nanos（int64）** 表示。
        
    - 禁止闰秒（`:60`）；禁止默认本地时区；非整纳秒输入直接报错（不允许四舍五入）。
        

- `uuid`
    
    - 语义：UUID。
        
    - v1 的 `Val` 文本表示锁死为 **8-4-4-4-12** 形式的十六进制（小写）：`xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`。
        
    - 禁止隐式纠正（如去掉大括号、接受 `urn:uuid:` 前缀、接受无连字符的 32 hex 等均不允许）。
        

（说明）v1 不引入 `json/decimal/enum` 等类型；除非能给出完全可移植的 canonicalization，否则一律后置。

### 3) typed_tuple_v1 的 canonical bytes（供 digest/跨语言复现）

为跨语言/跨引擎复现，定义 `canonical_bytes(rest_terms)` 的唯一构造。实现必须输出**完全相同**的 bytes，否则视为实现错误。

字节结构（TLV）：

```text
canonical_bytes(rest_terms) :=
    b"factpy\x00tup_v1\x00"
 || u32be(N)
 || for i in [0..N-1]:
        u8(tag_code)
     || u32be(len(value_bytes))
     || value_bytes
```

其中 `u32be` 为 4 字节无符号大端整数；`u8` 为 1 字节无符号整数。`N=len(rest_terms)`，且 `rest_terms[i]` 的顺序必须与 claim 的参数顺序一致。

tag_code（v1，锁死）：

- `0x08 entity_ref`
    
- `0x01 string`
    
- `0x02 int`
    
- `0x03 float64`
    
- `0x04 bool`
    
- `0x05 bytes`
    
- `0x06 time`
    
- `0x07 uuid`
    

`value_bytes` 的 canonicalization（v1，锁死）：

- `entity_ref`：canonical EntityRef token 的 UTF-8 bytes（必须是 `idref_v1:...`，禁止 pretty-display）。
    
- `string`：原字符串的 UTF-8 bytes（禁止任何 Unicode 归一/纠正）。
    
- `int`：ASCII 十进制最简形式（UTF-8 bytes），规则同 IdentityPolicy：`0` 为 `"0"`；负数以 `"-"`；禁止 `+`、空白、前导零；必须落在 int64。
    
- `float64`：big-endian 8 bytes 的 IEEE754 binary64 位模式；禁止 NaN/Inf；`-0.0` 必须 canonicalize 为 `+0.0`（全零位模式）。
    
- `bool`：`false -> 0x00`，`true -> 0x01`。
    
- `bytes`：原始 bytes（注意：若导入侧以 base64url no-pad 文本提供，必须先严格校验并解码得到原始 bytes；不得接受非 base64url/no-pad 形式并“纠正”）。
    
- `time`：`int64be(epoch_nanos_utc)`（必须可逆且精确到纳秒；禁止闰秒/默认时区/四舍五入）。
    
- `uuid`：16 bytes（RFC4122 network byte order；导入时必须来自 v1 canonical 8-4-4-4-12 小写文本并严格校验）。
    

说明：

- `typed_tuple_v1(...)` 在逻辑引擎内部可以用结构项/事实族表示；但导出包与审计 digest 一律以 `canonical_bytes(rest_terms)` 为准。
    

### 4) claim_arg 的落地表示要求（引擎侧）

`claim_arg` 是索引表：它的目标是让引擎能对 tuple 内部项做 join/filter；因此 `Val` 必须是**可原子化**的值（例如字符串、整数、符号常量）。

硬要求（必须）：

- `Val` 必须是可 join/filter 的原子项；不得把 `Val` 设为复合结构（list/tuple/record）。
    
- 若某类型在目标引擎中无法以原子项表示，必须采用本节锁死的 canonical 表示：
    
    - `bytes`：`Val` 为 base64url no-pad 字符串（保真；可逆解码）。
        
    - `uuid`：`Val` 为 v1 canonical 8-4-4-4-12 小写字符串。
        
    - `entity_ref`：`Val` 为 canonical EntityRef token 字符串。
        
    - `time/int/float64/bool`：若目标引擎不支持对应的原子域（int64/float64/bool），必须在导入/accept/export 任一环节**拒绝**该输入（不得静默降级为 string）。
        
- `claim_arg` 不是“强类型表”；类型由 `Tag`（以及 SchemaIR.arg_specs 的 type_domain）定义与校验，运行时类型只能作为承载，不能替代 `Tag`。
    

### 5) 错误处理（硬规范）

遇到下述任一情况必须拒绝（schema/导入/accept 任一环节均不得静默通过）：

- 未知 `Tag`（不在 v1 枚举内）。
    
- `Tag` 与 `Val` 不匹配（例如 `Tag=int` 但 `Val` 不是可验证的 int64；`Tag=bytes` 但 `Val` 不是合法 base64url no-pad）。
    
- 对同一 `Asrt`：`Idx` 不连续、缺洞、或重复。
    
- `Tag=entity_ref` 但 `Val` 不符合 `idref_v1:` canonical 格式（不得自动修复）。
    

### 6) 最小示例（必须）

示例 A（基础类型）：

- `rest_terms = [entity_ref(E1), string("de"), int(3)]`
    
- `typed_tuple_v1(...)` 概念形态：`O = typed_tuple_v1(rest_terms)`
    
- 对应 `claim_arg`（3 行，Idx=0/1/2）：
    
    - `claim_arg(Asrt, 0, E1, entity_ref).`
        
    - `claim_arg(Asrt, 1, "de", string).`
        
    - `claim_arg(Asrt, 2, 3, int).`
        
- `canonical_bytes(rest_terms)` 伪表示（结构展示）：
    
```text
b"factpy\x00tup_v1\x00"
+ u32be(3)
+ u8(0x08) + u32be(len(E1_utf8)) + E1_utf8
+ u8(0x01) + u32be(2)           + b"de"
+ u8(0x02) + u32be(1)           + b"3"
```

示例 B（bytes/time 展示“引擎侧 Val 表示 + Tag 保真”）：

- `rest_terms = [bytes("AAEC"), time("2026-02-21T00:00:00Z")]`
    
    - 其中 `bytes("AAEC")` 的 `Val` 是 base64url no-pad 文本（示例），解码得到原始 bytes `0x00 0x01 0x02`。
        
    - `time(...)` 输入必须带时区；规范化后得到 `epoch_nanos_utc = T_ns`（int64）。
        
- 对应 `claim_arg`：
    
    - `claim_arg(Asrt, 0, "AAEC", bytes).`（引擎侧存文本；可 join/filter；Tag=bytes 保真）
        
    - `claim_arg(Asrt, 1, T_ns, time).`（引擎侧存 int64 epoch-nanos；Tag=time 保真）
        
- `canonical_bytes(rest_terms)` 伪表示：
    
```text
b"factpy\x00tup_v1\x00"
+ u32be(2)
+ u8(0x05) + u32be(3) + b"\x00\x01\x02"          # bytes 原始 payload（由 base64url 严格校验+解码得到）
+ u8(0x06) + u32be(8) + int64be(T_ns)                # time epoch-nanos (UTC)
```

版本演进（预留）：

- `typed_tuple_v2` 必须采用新前缀与新 magic（例如 `b"factpy\x00tup_v2\x00"`）；v1 实现遇到未知版本必须拒绝（不得按 v1 解析）。
    
- 若需要兼容读，兼容策略必须显式声明为“可同时读 v1/v2，但写入/导出只产出单一版本”，并在导出包 manifest 中锁死。
    

禁止项（硬约束）：

- 禁止把 pretty EntityRef、或引擎内部匿名符号当作 `entity_ref` 值写入。
    
- 禁止对 `time/uuid/bytes` 做任何“隐式纠正”（如补时区、去掉大括号、自动 base64/hex 互转）。
    
- 禁止 float 的非确定性解析；实现无法保证正确舍入时，必须拒绝十进制输入。
    

与 SchemaIR.type_domain 的对齐规则：type_domain 必须能映射到上述 Tag 枚举之一；映射表放在 SchemaIR 章节或本节附表。

## claim_arg（解包索引表）

`claim_arg/4` 是 `typed_tuple_v1` 的“行式解包视图”，用于在引擎里 join/filter tuple 内部的项。

形式：

- `claim_arg(A, Idx, Val, Tag).`
    

参数语义：

- `A`：对应 `claim/4` 的 AssertionId
    
- `Idx`：参数位置索引（从 0 开始，指向 `rest_terms` 的第几个）
    
- `Val`：该位置的“值载体”
    
- `Tag`：该值的类型标签（与 typed_tuple_v1 内一致）
    

用途：

- view 层投影业务谓词时，从 claim_arg 取出某个参数位置的值
    
- 规则里如果需要对某个参数做约束（例如 `Lang == "en"`），也可以通过 view 先投影成二元/三元谓词，再在规则里写 builtin
    

注意：

- claim_arg 的存在不意味着你必须在业务规则里直接操作 claim_arg；默认规则只写 view。
    
- claim_arg 的 tag 语义必须锁死枚举，避免跨导出方言出现歧义（已锁定 canonical typed tags）。
    

---

## meta_*（断言元数据）

meta 只挂在 `A` 上，不进入业务谓词参数，不参与 identity，不参与断言等价性。

典型谓词（示例）：

- `meta_str(A, Key, Value).`
    
- `meta_num(A, Key, Value).`
	    
- `meta_bool(A, Key, Value).`
	    
- （可选）`meta_time(A, Key, EpochNanos).`（`EpochNanos` 为 UTC epoch-nanos int64）
	    
- （可选）`meta_json(A, Key, JsonToken).`
    

约束：

- meta key 必须被 `AssertionMetaSchema` 允许；未知 key 默认报错（strict）。
	    
- meta 的 canonicalization 在写入时完成，存储中只保 canonical 形式。
	    
- 硬约束：保留 key `ingested_at` 必须使用 `meta_time` 以 UTC epoch-nanos int64 写入；禁止用 `meta_str` 写 ISO8601。

- meta 合并顺序固定：`defaults -> batch -> save -> field`（后覆盖前）。
    

---

## active(A)（参与性过滤）

`active/1` 是 policy 接口之一：决定哪些断言纳入业务视图。

形式：

- `active(A).`（EDB 形式）或
    
- `active(A) :- ...`（IDB 形式）
    

典型语义：

- 默认全真（所有断言都参与），除非存在撤销/失效策略。
    
- 如果采用“撤销也是断言”的模型，则 active 通过 meta 或专门谓词过滤掉被撤销的 A。
    

实现边界（当前设计倾向）：

- 在 `policy_mode="edb"`：active 集合由 Python 侧预计算并导出为 facts。
    
- 在 `policy_mode="idb"`：允许导出规则定义 active，但遇到需要确定性 tie-break 的场景可能拒绝。

硬约束（MVP，必须）：`active(A)` 的语义仅由本文件“写入协议 §2”选定的撤销模型 `revokes/2` 决定；禁止使用 `meta_bool(A,"active",false)` 等 meta 模型作为替代失效机制（如需扩展必须 bump protocol_version）。
    

---

## chosen(A)（冲突组选择）

`chosen/1` 是 policy 接口之二：在同一冲突组内选择“代表断言”。

形式：

- `chosen(A).`（EDB）或
    
- `chosen(A) :- ...`（IDB）
    

冲突组定义来自 SchemaIR（硬约束）：

- `group_key = (PredId, S, Dims...)`
    
- Dims 由 `fact_key` / `mapping_key_positions` / temporal key 结构等确定
    
- 系统禁止运行时猜测冲突组；必须由 schema 驱动
    

常见语义：

- 对 `cardinality="multi"`：通常不需要 chosen（可以认为全部 chosen）
    
- 对 `cardinality="functional"`：同一 key 组只能有一个 chosen
    
- 对 mapping（如 `canon_of`）：必须 functional 且确定性，否则默认报错
    

确定性要求：

- chosen 必须可重复运行得到相同结果（同输入 facts 下）
    
- 若目标引擎缺乏聚合/排序能力，默认要求 `policy_mode="edb"` 由 Python 做确定化
