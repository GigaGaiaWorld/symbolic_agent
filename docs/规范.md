# FactPy Schema 规范（Entity / Identity / Field → SchemaIR）

目标：定义 FactPy 的 Schema 书写规范，以及 SchemaCompiler 如何把 Python `Entity` 类编译成 `SchemaIR`。`SchemaIR` 是 FactCompiler / RuleCompiler / PolicyCompiler / Exporter 的唯一权威输入；所有写入、规则、冲突组、chosen/active、导出语义均以 `SchemaIR` 为准，而非 Python 运行时对象。

## 1. 核心分离：Identity vs Field

### 1.1 Identity（实体锚点输入）

`Identity` 字段只用于生成/引用 `EntityRef`（实体常量）。要求尽可能稳定、可重放、与业务可变字段解耦。

推荐默认（安全性从高到低）

1. `(source_system, source_id)`
    
2. 外部 GUID/UUID
    
3. `synthetic_uuid`（框架生成并持久化）
    

禁止默认行为

- 禁止把易变字段（name/email/phone 等）作为 identity 输入。若必须内容寻址（content-addressed），必须显式声明为 `weak_identity` 并接受误合并不可逆风险（见 6.4）。
    

硬约束

- Identity 与 Field 的配置、校验、序列化协议完全解耦。
    
- Field 的 name/aliases/meta 不得进入 IdentityPolicy 输入。
    

### IdentityPolicy 与 EntityRef 生成（硬规范）

本节定义 **IdentityPolicy → EntityRef** 的唯一可实现规范。除本节明示规则外，任何实现不得对 identity 输入做“猜测/纠正/容错”。

#### 1) 输入：entity_type + identity_fields（有序、带类型）

- `entity_type`：来自 SchemaIR 的 `entity_type`（type_tag），大小写敏感。
    
- `identity_fields`：来自 SchemaIR 的 `identity_fields`（**有序**列表）。每个元素必须包含：
    
    - `name`：字段名（schema 侧的 Identity 名称）
        
    - `type_domain`：类型域（必须是下述枚举之一）
        
    - `value`：该字段值（必须与 type_domain 严格匹配）
        

硬约束（必须）：

- **顺序锁死**：序列化/哈希时必须按 SchemaIR.identity_fields 的顺序拼接；不得按 name 排序、不得跳过空值、不得根据运行时对象反射重排。
    
- **类型锁死**：type_domain 只能取：`string | int | float64 | bool | bytes | time | uuid | entity_ref`。未知类型一律报错；不得降级为 string。
    
- **输入闭包**：缺字段/多字段/字段名不匹配/类型不匹配一律报错；禁止将 `"123"` 当作 int、将 `"true"` 当作 bool 等隐式转换。
    

#### 2) EntityRef 内部 token（canonical）与 pretty-display

**内部 token（唯一 canonical）** 为 ASCII 字符串：

- `EntityRef = "idref_v1:" + entity_type + ":" + digest_b32`
    
- `entity_type` 字符集：`[A-Za-z][A-Za-z0-9_\\.\\-]{0,127}`（大小写敏感；不得包含 `:` 与空白）
    
- `digest_b32`：`base32(lowercase, no padding)` 对 `sha256` 输出的编码，长度固定 **52**（256bit）。
    

**pretty-display（仅展示）**：

- UI/日志可以展示为 `"<entity_type>__<digest_b32[:8]>"` 或其他更短形式；
    
- pretty-display **不得**作为任何输入回流到编译/导入/引擎；解析 EntityRef 时只接受上述 canonical token。
    

（可选，调试用）实现可以额外提供“原始 canonical bytes 的可视化”，但不得把它当作 EntityRef token 存储/导出。

#### 3) canonical serialization（idref_v1）：canonical_bytes 的构造

idref_v1 的哈希输入字节串记为 `canonical_bytes`，采用 **长度前缀 + 显式类型 tag** 的二进制编码（避免转义歧义）：

```text
canonical_bytes :=
    b"factpy\x00idref_v1\x00"
 || u32be(len(entity_type_utf8)) || entity_type_utf8
 || u32be(N)
 || for i in [0..N-1]:
        u32be(len(field_name_utf8)) || field_name_utf8
     || u8(tag_code)
     || u32be(len(value_bytes)) || value_bytes
```

其中 `u32be` 为 4 字节无符号大端整数；`u8` 为 1 字节无符号整数；`*_utf8` 为 UTF-8 编码后的字节序列。

tag_code 枚举（锁死）：

- `0x01 string`
    
- `0x02 int`
    
- `0x03 float64`（IEEE754 binary64）
    
- `0x04 bool`
    
- `0x05 bytes`
    
- `0x06 time`（int64 纳秒 UTC）
    
- `0x07 uuid`（16 bytes）
    
- `0x08 entity_ref`（canonical EntityRef 字符串）
    

##### value_bytes 编码规则（逐类型，必须）

- `string`
    
    - 输入必须是 Unicode 字符串；编码为 UTF-8 原字节（不做 trim/NFC/NFKC/casefold 等任何归一）。
        
    - 禁止：将 bytes/base64 当 string；禁止对非法 Unicode 做替换（例如 U+FFFD）；遇到不可编码/包含非法 surrogate 的输入必须报错。
        

- `int`
    
    - 输入必须是 **有符号 64-bit 整数**范围 `[-2^63, 2^63-1]`；编码为 ASCII 十进制最简形式（UTF-8 bytes）：
        
        - `0` 编码为 `"0"`
            
        - 负数以 `"-"` 前缀
            
        - 禁止 `+` 前缀、空白、前导零（例如 `"001"`）
            
    - 超范围或非整数类型一律报错（不得转 float64、不得取整）。
        

- `float64`
    
    - 输入必须是 IEEE754 binary64 可表示的有限值；`value_bytes = big-endian 8 bytes` 的 binary64 位模式。
        
    - 禁止：`NaN`、`+Inf`、`-Inf`（一律报错）。
        
    - `-0.0` 必须 canonicalize 为 `+0.0`（即全零位模式），不得保留负零。
        

- `bool`
    
    - 输入必须是布尔值；`false -> 0x00`，`true -> 0x01`。
        
    - 禁止用 `0/1`、`"true"` 等替代（类型不匹配即报错）。
        

- `bytes`
    
    - 输入必须是原始字节序列；`value_bytes` 为原样 bytes。
        
    - 禁止：hex/base64 文本串；禁止隐式字符编码转换。
        

- `time`
    
    - 语义为“绝对时间点（instant）”；编码为 **UTC 的 Unix epoch 纳秒**：`int64be(nanos_since_1970_utc)`。
        
    - 输入必须携带时区/offset（timezone-aware）；不得接受“本地时间/无时区时间”。
        
    - 允许的规范化：将输入换算到 UTC；除此之外禁止任何纠正。
        
    - 禁止：闰秒 `:60`、超出 int64 纳秒范围、或无法无损换算到纳秒精度（这些均报错）。
        

- `uuid`
    
    - 输入必须能解析为 16 bytes UUID；`value_bytes` 为 16 字节（RFC4122 network byte order）。
        
    - 允许的字符串形式：`xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`（大小写均可）。
        
    - 禁止：`urn:uuid:` 前缀、花括号 `{}`、非 16 bytes、或非规范长度（均报错）。
        

- `entity_ref`
    
    - 输入必须是 canonical EntityRef token（形如 `idref_v1:<entity_type>:<digest_b32>`）；`value_bytes` 为该字符串的 UTF-8 bytes。
        
    - 禁止：pretty-display、任何非 `idref_*` 前缀、或含空白/非法字符的 token（均报错）。
        

#### 4) hash 与输出 token（idref_v1）

- `digest = sha256(canonical_bytes)`（算法锁死为 SHA-256）
    
- `digest_b32 = base32(digest)`，要求：
    
    - RFC4648 Base32
        
    - 全小写
        
    - 不带 `=` padding
        

- 输出 EntityRef token：
    
    - `idref_v1:<entity_type>:<digest_b32>`
        

硬约束（必须）：

- 相同的 `(entity_type, identity_fields[name,type,value]...)` 必须生成完全相同的 EntityRef（跨进程/跨语言/跨平台一致）。
    
- 不得在 token 内嵌入随机数、时间戳、运行 id 等非确定性信息。
    

#### 5) 兼容性与升级（v1 → v2）

- `idref_v1` 的 canonical_bytes 前缀与编码规则一经发布不得变更；任何变更必须引入新版本前缀（例如 `idref_v2`）并同时变更 magic：`b"factpy\x00idref_v2\x00"`。
    
- 在同一个 Store/导出包中，对同一 `entity_type` **必须只有一个**生效的 idref 版本；禁止同一 identity 输入在同一环境下同时产生 v1/v2 两种 ref（除非引入显式等价映射并在导出包中声明）。
    

#### 6) 最小示例（测试向量）

entity_type：`Person`  
identity_fields（有序）：

1. `source_system: string = "HR"`
    
2. `source_id: string = "123"`
    

canonical_bytes（十六进制表示）：

```text
6661637470790069647265665f76310000000006506572736f6e000000020000000d736f757263655f73797374656d0100000002485200000009736f757263655f69640100000003313233
```

sha256(canonical_bytes)：

`4455c98939ddb385f120f6b9d57474cc07bab7a3c3d9c8c7b2f996a1d1642f0e`

digest_b32：

`irk4tcjz3wzyl4ja6245k5duzqd3vn5dypm4rr5s7glkdulef4ha`

最终 EntityRef：

`idref_v1:Person:irk4tcjz3wzyl4ja6245k5duzqd3vn5dypm4rr5s7glkdulef4ha`

### 1.2 Field（业务事实）

`Field` 仅用于生成业务谓词（facts），不参与实体锚点构造。字段必须声明 cardinality，并可声明分组维度（fact_key/dims）用于 functional 唯一性判定。

##### 实体引用字段（Entity-valued Field）

- 若 `Field` 的类型注解指向另一个 `Entity`（例如 `employer: Company`），则该 Field 产生的业务谓词是 “Entity → Entity” 关系。
    
- 其 PredId 命名规则与标量字段完全一致（第 2 节），但参数域（arg_kinds）为：`[entity, entity]`（或 `[E] + dims + [entity]` 若声明了 dims）。
    
- cardinality 语义仍然适用：
    
    - `functional`：对每个 key 组（默认仅 E + dims）至多一个目标实体
        
    - `multi`：允许多个目标实体（多条边）
        
    - `temporal`：只追加边记录，current 由 view/policy 推导（通常需 reify）


---

## 2. 业务谓词命名：Python 字段名 vs PredId

### 2.1 Python 字段名（API 名称）

Python 字段名是类属性名（例如 `age`），用于 Python API：`person.age.set(...)`。它是开发接口，原则上不应频繁变更。

### 2.2 业务谓词名（PredId，逻辑世界名称）

业务谓词名是写入 `claim(A, PredId, ...)` / view / 导出的 predicate id。SchemaCompiler 生成并写入 SchemaIR，后续所有阶段只使用 PredId。

规则（必须写死）

- 若 Field 指定 `Field(name="has_age")`，则 PredId 使用该 override：`"<owner>:has_age"`
    
- 否则 PredId 默认：`"<owner>:<py_field_name>"`
    

重要澄清

- `Field(name=...)` 只改变 PredId，不改变 Python 字段名。
    
- claim/view/export 永远使用 SchemaIR 里的 PredId；这不是运行时替换，而是 schema 编译结果。
    

---

## 3. Cardinality、fact_key 与冲突组（chosen 分组）

### 3.1 cardinality（必须）

- `multi`：同一 key 组内可存在多个 value；view 默认保留全部。
    
- `functional`：同一 key 组内最多一个 value；冲突必须通过 chosen 策略确定化或报错（由 policy 决定）。
    
- `temporal`：只追加历史（append-only）；“当前值”只能由 view/policy 推导，禁止物理覆盖。
    

### 3.2 fact_key（functional 唯一性分组维度）

目的：表达 functional 的“唯一性范围”。默认 key 组为 `{E}`（主实体）。当字段语义是“带维度的属性”时必须显式声明额外维度。

直觉：对每个 key 组合，最多一个 value。  
形式化：`∀K, v1, v2. attr(K,v1) ∧ attr(K,v2) → v1=v2`  
其中 `K` 即 `(E + dims)`。

两种建模方式（Schema 允许二选一）  
A) 允许 n-ary 业务谓词：`pred(E, dim1, dim2, ..., value)`  
B) 若需/选择二元化，则必须 reify 成 record entity（见 6.1）

### 3.3 参数序列与 group_key_indexes（SchemaIR 必须可计算）

为保证下游 chosen 冲突组计算确定性，SchemaCompiler 必须把每个 Field 归一成固定的业务谓词参数序列，并据此计算 `group_key_indexes`。

硬规范（推荐默认）

- 业务谓词逻辑参数序列固定为：`[E] + dims + [value]`
    
- `group_key_indexes` 必须包含：
    
    - `0`（E / subject）
        
    - dims 对应的位置（按 dims 顺序）
        
- `group_key_indexes` 不包含 value 位置
    

冲突组键（Policy/Store 计算用）

- `K = (PredId, args[i] for i in group_key_indexes)`
    
- functional 冲突：同一 `K` 出现多条候选断言
    

---

## 4. aliases 与兼容性（只影响解析，不影响 canonical PredId）

`aliases=[...]` 用于兼容旧名称/外部导入映射，属于 SchemaIR 的“解析映射表”，不得成为写入 claim 的 PredId。

规则

- 导入解析阶段允许把 alias 映射到 canonical PredId。
    
- 写入、view、导出只使用 canonical PredId（见第 2 节命名规则）。
    
- aliases 不得影响 identity，不得进入冲突组 key 的定义。
    

---

## 5. SchemaIR 最小必备内容（供下游使用）

每个 Entity 类型至少提供：

- `entity_type`（type_tag）
    
- `identity_fields`（有序）与 IdentityPolicy 信息（canonical serialization 协议引用）
	    
- （若该 EntityType 允许 materialize_as="fact"）必须提供 `projection_pred_id` 与 `projection_arg_order`
	    

每个业务谓词（由 Field 生成）至少提供：

- `pred_id`（canonical）
    
- `owner_type`（例如 Person）
    
- `arity` 与 `arg_kinds`（entity/value/tuple 等类型域）
    
- `cardinality`（multi/functional/temporal）
    
- `dims`（fact_key 维度名列表，已归一顺序）
    
- `group_key_indexes`（chosen 冲突组计算依据）
    
- `aliases`（可选：解析映射表，仅导入用）
    
- `is_mapping / mapping_* / tie_break`（若为 mapping，见第 6.3）
	    
- `arg_specs`（至少包含每个参数的 `name` 与 `type_domain`）
	    

注意：SchemaIR 的这些字段必须是“编译期确定”的；禁止在运行时根据数据形态变化。

### SchemaIR：结构（JSON Schema）与 schema_digest（硬规范）

* SchemaIR 顶层结构与字段类型（含 arg_specs/projection_* 等）
* canonical 序列化规则（key 排序、数组稳定顺序、显式版本号）
* schema_digest 定义（sha256 over canonical bytes）与变更检测规则
* 下游约束：禁止运行时推断/补字段；type_domain 与 Tag 枚举对齐（见 `/Users/zhenzhili/symbolic_agent/docs/断言层 证据层.md` 的 `typed_tuple_v1 与 claim_arg：编码与 Tag 枚举（硬规范）`）

补充硬规范（必须）：

SchemaIR 的 canonical bytes 采用 RFC 8785 JCS（JSON Canonicalization Scheme）；digest token 统一为 `sha256:<64hex>`（hex 必须小写）。
`schema_digest` 定义为 `sha256:<64hex>`，其输入为上述 canonical bytes；任何字段缺失/额外字段/默认值推断/数组顺序变化都会改变 schema_digest，因此禁止运行时补字段或省略字段。
`arg_specs[].type_domain` 的 canonical 值域必须逐字等于 `typed_tuple_v1.Tag` 枚举之一：`entity_ref|string|int|float64|bool|bytes|time|uuid`；未知值必须拒绝。

SchemaIR skeleton（10 行，仅示意字段形状与命名）：

```json
{
  "schema_ir_version": "schema_ir_v1",
  "entities": [{"entity_type":"Person","identity_fields":[{"name":"source_id","type_domain":"string"}]}],
  "predicates": [{"pred_id":"person:country","cardinality":"functional",
    "arg_specs":[{"name":"E","type_domain":"entity_ref"},{"name":"Country","type_domain":"entity_ref"}],
    "group_key_indexes":[0], "aliases": []}],
  "projection": {"entities": [], "predicates": []},
  "protocol_version": {"idref":"idref_v1","tup":"tup_v1"},
  "generated_at": "2026-03-02T10:11:12Z"
}
```

硬约束：上述 skeleton 的顶层 key/层级结构即为 SchemaIR v1 的 canonical 结构；不得改名或改层级（新增字段只能在既定对象下新增且必须进入 JCS/digest）。

---

## 6. Reification、Temporal、Mapping、Weak Identity（硬规范）

### 6.1 何时必须 reify（提升为 record entity）

满足任一条件必须 reify 成 record entity（关系实体化）：

- 关系需要挂载自身属性（边上有属性）
    
- 关系天然是 n-ary 且无法/不愿直接用 n-ary 业务谓词表示
    
- temporal（valid_time / versioned）字段
    

reify 后 SchemaIR 必须生成明确的“角色/属性谓词集合”（role predicates），供 FactCompiler 写入、RuleCompiler 展开、PolicyCompiler/view 生成使用。

硬约束（必须）：对每个 reified record entity type `<T>`，SchemaCompiler 必须生成 `<T>:exists` 以及 `<T>:<role>` 角色谓词全集，并且 accept 写回必须复用这些 PredId（不得临时拼接字符串）。

### 6.2 temporal（valid_time / versioned）

temporal 字段的写入载体固定为 reified record entity，并产出标准角色谓词（示例语义）：

- valid_time：`owner`, `value`, `start`, `end`, `dims...`
    
- versioned：`owner`, `value`, `version`, `current_flag`, `dims...`
    

硬约束

- 写入永远 append-only（新增 record）。
    
- “当前值”不得通过覆盖历史事实实现；只能通过 view/policy 推导（或 policy_mode="edb" 由 Python 预计算后导出）。
    

### 6.3 mapping（canon_of 等）

mapping 谓词（例如 `canon_of(Mention, Canonical)`）必须在 SchemaIR 中显式标记为 mapping，并具备单值约束与确定化策略接口。

SchemaIR 必须包含：

- `is_mapping = true`
    
- `mapping_kind = "single_valued"`（本系统默认关注单值映射）
    
- `mapping_key_positions`（例如 canon_of 默认 [0]）
    
- `mapping_value_positions`（例如 [1]）
    
- `tie_break`（可空；空表示默认 mode="error"）
    

硬约束

- 不允许不稳定多解“静默通过”。默认冲突报错（mode="error"）。
    
- 若需要 tie-break 且目标方言缺少稳定聚合/排序能力，则必须 `policy_mode="edb"`（Python 预计算），`policy_mode="idb"` 必须显式拒绝。
    

### 6.4 weak identity（可选，默认禁用）

内容寻址 identity（例如 Hash(name,dob)）若启用，必须显式声明为弱身份策略 `weak_identity` 并承认风险：

- 同输入合并不可逆（误合并会污染推导）
    
- 推荐默认路线：使用 Mention/Canonical + canon_of 做“软合并”，而不是物理合并实体
    

---

## 7. 编译期强校验（SchemaCompiler 必须报错，不得静默纠正）

SchemaCompiler 至少执行：

Entity 级

- 每个 Entity 至少一个 Identity（或显式声明 external/synthetic 的替代方案）
    
- Identity 字段序列可 canonical serialization，且顺序确定
    

Field/Predicate 级

- cardinality 合法（multi/functional/temporal）
    
- functional 字段：fact_key/dims 名称可解析且顺序确定；能生成 group_key_indexes
    
- temporal 字段：temporal_mode 必填；record role predicates 全集生成成功
    
- mapping：is_mapping/mapping_kind/key/value_positions/tie_break 配置一致（或明确 mode="error"）
    
- aliases 不得与 canonical PredId 冲突（解析映射表必须无歧义）
    

---

## 8. 最小示例（可作为文档锚点）

```python
from factpy import Entity, Identity, Field

class Person(Entity):
    source_system: str = Identity()
    source_id: str = Identity()

    # canonical PredId: person:has_age(E, Age)
    age: int = Field(name="has_age", cardinality="functional")

    # multi: person:name(E, Name)
    name: str = Field(cardinality="multi")

    # functional with dims: person:name_by_lang(E, Lang, Name)
    name_by_lang: str = Field(cardinality="functional", fact_key=["lang"])

class Company(Entity):
    source_system: str = Identity()
    source_id: str = Identity()
    sector: str = Field(cardinality="functional")
    
class Employment(Entity):
    uid: str = Identity(default_factory="uuid4")

    employee: Person = Field(cardinality="functional")   # employment:employee(Emp, Person)
    employer: Company = Field(cardinality="functional")  # employment:employer(Emp, Company)

    since: int = Field(cardinality="functional")
    title: str = Field(cardinality="functional")

```

SchemaIR 关键产物（读者应能对照实现）

- `Person.age` → `pred_id="person:has_age"`, `arity=2`, `args=[E,Age]`, `group_key_indexes=[0]`
    
- `Person.name_by_lang` → `pred_id="person:name_by_lang"`, `arity=3`, `args=[E,Lang,Name]`, `group_key_indexes=[0,1]`
    
