from __future__ import annotations
import csv
import re
from dataclasses import dataclass
from typing import Any, Dict, Iterable, List, Tuple
from neo4j import GraphDatabase

Schema = Dict[str, Any]


def _safe_label(label: str) -> str:
    safe = re.sub(r"[^A-Za-z0-9_]", "_", label)
    if not safe or not re.match(r"^[A-Za-z_]", safe):
        safe = f"L_{safe}"
    return safe

@dataclass(frozen=True)
class Neo4jCfg:
    uri: str
    user: str
    password: str
    database: str = "neo4j"

def _primary_key_for_label(schema: Schema, label: str) -> str:
    props = schema["nodes"].get(label)
    if props is None:
        # Allow implicit value nodes (e.g., Age/Years) not declared in schema.
        return "value"
    if not props:
        raise ValueError(f"Label {label} has no properties; need a primary key.")
    return props[0]  # 从简单开始：第一个属性为主键（name）

def run(cfg: Neo4jCfg, query: str, params: Dict[str, Any] | None = None) -> None:
    params = params or {}
    with GraphDatabase.driver(cfg.uri, auth=(cfg.user, cfg.password)) as driver:
        driver.verify_connectivity()
        driver.execute_query(query, params, database_=cfg.database)

def ensure_constraints(cfg: Neo4jCfg, schema: Schema) -> None:
    for label in schema["nodes"].keys():
        pk = _primary_key_for_label(schema, label)
        cname = f"{label.lower()}_{pk}_unique"
        q = (
            f"CREATE CONSTRAINT {cname} IF NOT EXISTS "
            f"FOR (n:{_safe_label(label)}) REQUIRE n.{pk} IS UNIQUE;"
        )
        run(cfg, q)


def chunks(lst: List[Any], size: int) -> Iterable[List[Any]]:
    for i in range(0, len(lst), size):
        yield lst[i:i+size]

def _is_number_str(s: str) -> bool:
    s = s.strip()
    if not s:
        return False
    return bool(re.fullmatch(r"-?\d+(\.\d+)?", s))


def _parse_number(s: str) -> Any:
    s = s.strip()
    if re.fullmatch(r"-?\d+", s):
        try:
            return int(s)
        except ValueError:
            return s
    if re.fullmatch(r"-?\d+\.\d+", s):
        try:
            return float(s)
        except ValueError:
            return s
    return s


def _maybe_coerce_numeric(values: List[Any]) -> List[Any]:
    str_vals = [v for v in values if isinstance(v, str)]
    if str_vals and all(_is_number_str(v) for v in str_vals):
        return [(_parse_number(v) if isinstance(v, str) else v) for v in values]
    return values


def import_nodes(cfg: Neo4jCfg, label: str, pk: str, values: List[Any], batch: int = 5000) -> None:
    values = _maybe_coerce_numeric(values)
    safe_label = _safe_label(label)
    q = (
        "UNWIND $rows AS row\n"
        f"MERGE (n:{safe_label} {{{pk}: row.v}});"
    )
    for part in chunks(values, batch):
        rows = [{"v": v} for v in part]
        run(cfg, q, {"rows": rows})

def import_rels(
    cfg: Neo4jCfg,
    src_label: str, rel_type: str, dst_label: str,
    src_pk: str, dst_pk: str,
    pairs: List[Tuple[Any, Any]],
    batch: int = 5000
) -> None:
    if pairs:
        obj_vals = [o for _, o in pairs]
        obj_vals = _maybe_coerce_numeric(obj_vals)
        pairs = [(s, obj_vals[i]) for i, (s, _) in enumerate(pairs)]
    safe_src = _safe_label(src_label)
    safe_dst = _safe_label(dst_label)
    q = (
        "UNWIND $rows AS row\n"
        f"MATCH (s:{safe_src} {{{src_pk}: row.sub}})\n"
        f"MATCH (o:{safe_dst} {{{dst_pk}: row.obj}})\n"
        f"MERGE (s)-[:{rel_type.upper()}]->(o);"
    )
    for part in chunks(pairs, batch):
        rows = [{"sub": s, "obj": o} for s, o in part]
        run(cfg, q, {"rows": rows})

# when import graph from local csv files, load data from csv files

def read_col_csv(path: str, col: str) -> List[str]:
    out: List[str] = []
    with open(path, "r", encoding="utf-8", newline="") as f:
        r = csv.DictReader(f)
        if col not in r.fieldnames:
            raise ValueError(f"{path} missing column {col}, has {r.fieldnames}")
        for row in r:
            v = (row.get(col) or "").strip()
            if v:
                out.append(v)
    return out

def read_rel_csv(path: str, sub_col: str = "sub", obj_col: str = "obj") -> List[Tuple[str, str]]:
    out: List[Tuple[str, str]] = []
    with open(path, "r", encoding="utf-8", newline="") as f:
        r = csv.DictReader(f)
        if sub_col not in r.fieldnames or obj_col not in r.fieldnames:
            raise ValueError(f"{path} must have columns {sub_col},{obj_col}; has {r.fieldnames}")
        for row in r:
            s = (row.get(sub_col) or "").strip()
            o = (row.get(obj_col) or "").strip()
            if s and o:
                out.append((s, o))
    return out


# =================== Main Functions ===================
# import graph from structured data, not csv files
def import_graph(
        cfg: Neo4jCfg,
        schema: Schema,
        nodes: Dict[str, List[Any]],                 # label -> list of pk values
        rels: Dict[Tuple[str, str, str], List[Tuple[Any, Any]]], # (src, rel, dst) -> list of (src_pk, dst_pk)
    ) -> None:
    ensure_constraints(cfg, schema)
    for label, vals in nodes.items():
        pk = _primary_key_for_label(schema, label)
        import_nodes(cfg, label, pk, vals)

    # build implicit dst nodes from relationships if dst label not declared
    implicit_nodes: Dict[str, List[Any]] = {}
    for (src, rel, dst), pairs in rels.items():
        if dst not in schema["nodes"] and dst not in nodes:
            implicit_nodes.setdefault(dst, [])
            implicit_nodes[dst].extend([o for _, o in pairs])

    for label, vals in implicit_nodes.items():
        pk = _primary_key_for_label(schema, label)  # will be "value"
        # de-dup while preserving order
        seen = set()
        uniq_vals = []
        for v in vals:
            key = (type(v), v)
            if key in seen:
                continue
            seen.add(key)
            uniq_vals.append(v)
        import_nodes(cfg, label, pk, uniq_vals)

    for (src, rel, dst), pairs in rels.items():
        src_pk = _primary_key_for_label(schema, src)
        dst_pk = _primary_key_for_label(schema, dst)
        import_rels(cfg, src, rel, dst, src_pk, dst_pk, pairs)

def import_graph_from_csv_files(
    cfg: Neo4jCfg,
    schema: Schema,
    node_files: Dict[str, str],                 # label -> local path
    rel_files: Dict[Tuple[str, str, str], str], # (src, rel, dst) -> local path
) -> None:
    ensure_constraints(cfg, schema)

    # nodes
    for label, path in node_files.items():
        pk = _primary_key_for_label(schema, label)
        vals = read_col_csv(path, pk)
        import_nodes(cfg, label, pk, vals)

    # rels
    for (src, rel, dst), path in rel_files.items():
        src_pk = _primary_key_for_label(schema, src)
        dst_pk = _primary_key_for_label(schema, dst)
        pairs = read_rel_csv(path, "sub", "obj")
        import_rels(cfg, src, rel, dst, src_pk, dst_pk, pairs)
