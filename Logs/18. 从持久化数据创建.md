
> [!note] ME:

假设我们有已经持久化的若干Fact, 现在我需要引用它们来创造新的Rel, 可以怎么做?

> [!warning] CODEX:

可以。当前实现里，**Rel 的端点只能用“Fact 实例 / key 字段 / InstanceRef”来解析**，因此你有 3 种标准做法：

**1. 直接用已持久化的 Fact Instance**
如果你持久化的是 `Instance.to_dict()` 的结果，可以用 `Instance.from_dict(...)` 还原，然后直接作为端点：

```python
alice = Instance.from_dict(alice_payload, registry=registry)
darmstadt = Instance.from_dict(city_payload, registry=registry)

rel = Instance(schema=lives_in, terms=[alice, darmstadt, 2020])
```

**2. 用 key dict（不需要完整实例）**
只要提供 key_fields 就行：

```python
rel = Instance(
    schema=lives_in,
    terms=[{"Name": "alice"}, {"Name": "darmstadt"}, 2020],
)
```

或 dict 形式：

```python
rel = Instance(
    schema=lives_in,
    terms={
        "sub_key": {"Name": "alice"},
        "obj_key": {"Name": "darmstadt"},
        "since": 2020,
    },
)
```

**3. 用 InstanceRef（最轻量引用）**
当你只想引用已有 fact，而不想传完整 props：

```python
from symir.ir.fact_schema import InstanceRef

alice_ref = InstanceRef(schema_id=person.schema_id, key_values={"Name": "alice"})
city_ref = InstanceRef(schema_id=city.schema_id, key_values={"Name": "darmstadt"})

rel = Instance(schema=lives_in, terms=[alice_ref, city_ref, 2020])
```

---

**注意**
- 当前实现**不支持只用 `entity_id` 创建 Rel**。端点解析必须依赖 key_fields（或完整实例）。
- 如果你持久化时只保留了 `entity_id`，将无法回放成 Rel，建议持久化时保留 key_fields（或直接用 `InstanceRef` 的 key_values）。

如果你想让我支持 “只用 entity_id 也能建 Rel”，可以扩展 `_resolve_endpoint` 加一个分支。

> [!note] ME:

我说的是Fact的schema本地持久化了, 然后想创建新的Rel schema, 这需要引用Fact

> [!warning] CODEX:

可以。**Rel 必须引用 Fact 对象（或 `PredicateSchema` kind=fact 的对象），不能只给 `schema_id`**。做法是先把本地持久化的 Fact schema 还原成对象，再用它们创建 Rel。

### 情况 A：你持久化的是 FactLayer（推荐）
```python
import json
from symir.ir.fact_schema import FactLayer, ArgSpec, Rel

payload = json.load(open("schema.json", "r", encoding="utf-8"))
registry = FactLayer.from_dict(payload)

person = registry.fact("person")
company = registry.fact("company")

works_at = Rel(
    "works_at",
    sub=person,
    obj=company,
    props=[ArgSpec("since:int"), ArgSpec("title:string")],
)

registry = FactLayer([*registry.predicates(), works_at])
```

### 情况 B：你只持久化了 Fact 的 dict 列表
```python
from symir.ir.fact_schema import FactLayer, PredicateSchema, ArgSpec, Rel

fact_dicts = json.load(open("facts_only.json", "r", encoding="utf-8"))
facts = [PredicateSchema.from_dict(d) for d in fact_dicts]

registry = FactLayer(facts)
person = registry.fact("person")
company = registry.fact("company")

works_at = Rel("works_at", sub=person, obj=company, props=[ArgSpec("since:int")])
registry = FactLayer([*registry.predicates(), works_at])
```

### 情况 C：你用 diskcache 缓存了 predicate schema
```python
from symir.ir.fact_schema import load_predicate_schemas_from_cache, FactLayer, ArgSpec, Rel

facts = load_predicate_schemas_from_cache()
registry = FactLayer(facts)

person = registry.fact("person")
company = registry.fact("company")

works_at = Rel("works_at", sub=person, obj=company, props=[ArgSpec("since:int")])
registry = FactLayer([*registry.predicates(), works_at])
```

**要点**
- Rel 构造需要 **Fact 对象**（或 kind="fact" 的 schema），不能只传 `schema_id`。
- 只有加载了 Fact 的完整 schema，Rel 才能正确计算 `schema_id`、`endpoints`、`derived_signature`。

如果你想要一个 `registry.add_predicate(...)` 的简洁 API，我可以加一个。


> [!note] ME:

这符合工程化的规范吗?

> [!warning] CODEX:

总体来说 **是符合工程化规范的**，原因很直接：

1. **Rel 的结构依赖 Fact 的结构**  
   `Rel` 的 `schema_id / endpoints / derived_signature` 都要用到 `Fact` 的 `key_fields` 和 `signature`。没有完整 Fact 对象就无法保证一致性和可验证性，这符合“结构先于引用”的工程原则。

2. **可验证、可迁移**  
   先加载事实 schema，再构造关系 schema，能在构造时立即校验（比如 key_fields、arity、schema_id hash 一致性），避免“静默错误”。

3. **与主流实践一致**  
   绝大多数 schema‑first 的系统（Graph/DB/ETL）都要求先有节点类型定义，再定义关系类型。这是为了可读、可维护、可演化。

---

如果你觉得“必须先还原 Fact 才能建 Rel”太重，可以加 **工程化友好 API**（不改变原则，只是包装）：

- `registry.rel(name, sub="person", obj="company", props=[...])`  
  内部用 `registry.fact("person")` / `registry.fact("company")` 自动解析。

- 或 `Rel.from_ids(registry, name, sub_id, obj_id, props=[...])`  
  依然用 registry 查回 Fact 对象，保证正确性。

---

**结论**  
这种做法是合理且规范的，只是 UX 可以更轻量。  
如果你同意，我可以补一个 `RelFactory` / `FactLayer.rel_from_ids(...)` 来减少你手动还原 Fact 的步骤。

> [!note] ME:

先不用增加什么, 把这部分的内容详细补充到Readme文档中

> [!warning] CODEX:

已补充到 `/Users/zhenzhili/symbolic_agent/src/symir/ir/README.md` 的 **Rel Schema From Persisted Facts** 章节，包含：

- 为什么必须用 Fact 对象（工程规范理由）
- 三种实际流程（FactLayer / 仅 facts dict / diskcache）
- 代码示例
- 简要的未来可选 API（不实现）

如果你希望把这段再精简或移动到主 README，也可以告诉我。

