
> [!note] ME:

在ir文件夹下的Readme中更新完整的Rules的设计和规则, 并给出充足的示例

> [!warning] CODEX:

Done. I updated the IR README with a full Rules design section and multiple concrete examples (basic fact rule, rel rule, expressions, negation, validation, serialization, and LLM decoding).  

Updated file:
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/README.md`

Highlights included:
- `Rule = predicate + conditions`, `Cond = literals + prob`
- `Ref(schema_id=...)` and `Expr(...)` usage
- Expressions: `Call`, `Unify`, `If`, `NotExpr`
- Validation with `RuleValidator`
- LLM decoding note: schema validates **conditions only**, head provided externally

I didn’t run tests. If you want a preview snippet or additional examples (e.g., compact vs verbose decoding JSON), say the word.

> [!note] ME:

能不能让Var和Const的datatype不提供用户的接口, 而是导入的schema来填充, 这样正好承接数据类型验证

> [!warning] CODEX:

已完成：

**变更点**
- `Var` / `Const` 不再接受 `datatype`（接口层彻底移除）。
- 类型验证完全由 **schema signature** 驱动：
  - `Ref(schema=...)` 会在创建时校验 `Const` 类型。
  - `RuleValidator` / `build_pydantic_rule_model` 也会按 signature 校验 `Const`。
- `build_pydantic_rule_model` / `build_responses_schema` 已适配当前 rule 结构，并统一使用 `schema_id`（不再用 `predicate_id`）。
- JSON schema 中 `var/const` 不再包含 `datatype` 字段，严格模式会拒绝它。

**示例**
```python
Ref(schema=person, terms=[Var("Name"), Const("alice")])   # OK
Ref(schema=person, terms=[Var("Name"), Const(123)])       # ❌ 类型不匹配
```

**已改文件（关键）**
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/expr_ir.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/rules/constraint_schemas.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/examples/parse_llm_response.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/README.md`（规则与类型说明已更新）

我没有运行测试。  
如果你希望 **仍兼容旧 payload 中的 `datatype` 字段**（容忍但忽略），我可以再加一层兼容逻辑。

