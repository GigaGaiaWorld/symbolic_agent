
> [!note] ME:

这里是自动处理出Sub, Obj, Since, Title, SubName, SubAddr, SubAge, ObjName等, 而用户只需要知道这个命名约定就可以直接用是吗?

> [!warning] CODEX:

还没有自动完成。  
现在必须你自己显式写 `Var("Sub") / Var("SubName")` 之类的变量名。

如果你希望“只要遵守命名约定就自动补”，我可以加一个规则构造器或辅助函数，完成这些事：

**自动补的内容可以包含：**
- 自动生成 `Sub/Obj/Since/Title` 等变量列表作为 head terms  
- 自动插入 `Unify(Sub, Ref(person, [SubName, SubAddr, SubAge]))`  
- 自动插入 `Unify(Obj, Ref(company, [ObjName, ...]))`  

你只需要告诉我这两点：
1. **命名约定是否固定**：`Sub/Obj` + `Sub<ArgName>` / `Obj<ArgName>`  
2. **是否默认插入 Unify**（不写也自动加）

你确认后我就实现。

> [!note] ME:

能不能这里先只是先包含一套约定, 因为我认为无论是具体的自动插入Unify(Sub, Ref(predicate=person, terms=[SubName, SubAddr, SubAge]), Unify(Obj, Ref(predicate=company, terms=[ObjName])以及        Ref(predicate=person, terms=[SubName, SubAddr, SubAge]),  # optional: assert existence
        Ref(predicate=company, terms=[ObjName]), head_terms = [Sub, Obj, Since, Title]都应该是Render部分渲染成具体代码时需要的逻辑, 你觉得呢?

> [!warning] CODEX:

可以的。你想要的写法 **`Unify(Sub, Ref(person, ...))` 已经支持**，因为我把 `Ref` 作为表达式项（ExprIR）处理了。渲染时会输出：

```
Sub = person(SubName, SubAddr)
```

---

关于你提的“只规定命名约定，逻辑由渲染阶段补齐”，我同意这是合理的做法。  
实现上我建议加一个 **“规则展开/预处理”**（在渲染前做），把隐含绑定显式化，这样后端保持一致。

**约定 + 渲染展开（我建议的规则）**
- 约定变量名：`Sub` / `Obj`
- 端点字段变量：`Sub<Name>` / `Obj<Name>`  
- 关系属性变量：直接用 prop 名（如 `Since`, `Title`）

渲染前自动插入：
```
Unify(Sub, Ref(person, [SubName, SubAddr, SubAge]))
Unify(Obj, Ref(company, [ObjName, ...]))
```

最终渲染成你要的结构化项形式。

---

**我需要你确认两点，再开始实现“渲染期自动展开”：**
1. 结构化绑定里用 **完整 signature** 还是 **只用 key_fields**？
2. 是否还要自动补 `Ref(person, ...)` / `Ref(company, ...)` 作为“事实存在约束”？  
   还是仅做 `Unify(Sub, Ref(...))` 就够？

你确认后我就加一个 `expand_rule(...)`，由渲染器自动调用。

> [!note] ME:

实际上我有些迷惑了, 因为Fact和Rel, 它们创建后都是json格式的数据模板, 而Rule应该也是一个干净的数据模板, 我们这种渲染前自动插入带有了处理它自身的逻辑, 变成四不像了, 我建议从rule中创建出的也是包含prop的数据模板, 让我们也有从payload数据中重构一个Rule类的能力, 就像是loaded = FactLayer.from_dict(payload)

但是我的想法还是很模糊, 你有什么成熟的建议吗?

> [!warning] CODEX:

你的直觉是对的：**Rule 也应该是干净的数据模板**，渲染器不应该“偷偷补逻辑”。  
成熟做法是把“便捷语法”和“规范化规则”拆开：

**推荐架构（最稳妥）**
1. **RuleSpec（用户友好层）**  
   允许写简洁约定，比如只写 `Sub/Obj/SubName/...`。  
2. **Rule（规范层，canonical）**  
   **所有隐含逻辑显式化**，比如：  
   - `Unify(Sub, Ref(person, [SubName, SubAddr]))`  
   - `Unify(Obj, Ref(company, [ObjName]))`  
   - `head.terms` 明确列出 `[Sub, Obj, Since, Title]`  
3. **Renderer 只吃 Rule（规范层）**  
   渲染只负责“转成目标语言”，不再做逻辑推导。

这样你可以：
- `RuleSpec -> normalize() -> Rule`
- `Rule.to_dict()` / `Rule.from_dict()` 实现稳定回放  
- 不会出现“渲染时突然改变规则结构”的情况

---

## 你要的“结构化引用”仍然保留
你完全可以在规范层用：

```python
Unify(Var("Sub"), Ref(predicate=person, terms=[Var("SubName"), Var("SubAddr")]))
```

它是数据模板的一部分，不是渲染时补出来的逻辑。

---

## 如果你不想引入 RuleSpec
也可以只保留 `Rule`，但提供一个**builder 工具**：

```python
rule = RuleBuilder.from_convention(
    head=employment,
    bodies=[...],
    convention="subobj",
    bind_endpoints=True,
    use_signature="full",
)
```

这一步只是**生成 Rule**，并不是渲染逻辑。

---

## 结论（我的建议）
- **保持 Rule 纯数据** ✅  
- **“自动补逻辑”放到 normalize/build 阶段** ✅  
- **Renderer 只负责输出，不插逻辑** ✅  

---

如果你同意这个方向，我可以做两件事：
1. 加一个 `RuleBuilder.from_convention(...)`，把你说的命名约定转成明确的 `Unify + Ref`。
2. 规则的 `to_dict()/from_dict()` 保持完全可回放（只存 canonical）。

你想先做哪一个？


> [!note] ME:

但是Unify(Var("Sub"), Ref(predicate=person, terms=[Var("SubName"), Var("SubAddr")]))这是自动化的逻辑, 也就是说对于任何Rule的定义都会有这个代码, 它本身并不包含任何额外信息, 只有用户定义的部分才有存储的价值, 我的意思是从Rule中构建出来的应该是一个可以持久化的数据模板, 

我认为可以这么构想, 在Render一个rule为实际的逻辑代码, 并query后, 我们将获得它head对应的Fact/Rel格式数据的多个实例, 也就是说rule本身同时是一个可持久化的数据模板和一个实例的构造器, 我们需求“补全”逻辑的时候, 正是活动这些实例的时候, 因此, 我们需要在render阶段进行逻辑的补全, 并且是根据不同的语言进行不同的逻辑补全, 因为这个补全逻辑的过程是自动化/同质化的过程, 适合存储在代码而不是数据本身. 你如何看待?

> [!warning] CODEX:

我理解你的方向：**Rule 是干净的模板**，补全逻辑属于“执行/渲染阶段”。这在工程上是合理的，很多系统也这么做。  
但要注意一个关键点：**必须让“补全规则”是确定且可解释的**，否则同一条 Rule 在不同后端会生成不同语义，难以调试。

---

## 我对你方案的看法（结论）

**我认可你的设计前提**：  
Rule 保持最小模板，补全逻辑放在渲染阶段，且根据后端做差异化处理。

**但我建议补一层“规范化策略说明”**，以保证可复现与可追溯：

### 关键改进：把“补全策略”显式化
在 Rule 上增加一个轻量字段，例如：

```python
rule = Rule(
    head=employment,
    bodies=[body1, body2],
    expand_policy="subobj_struct"  # or "none"
)
```

- `expand_policy="subobj_struct"` 表示：
  - 当 head 是 Rel 时，渲染阶段自动插入：
    - `Sub = person(SubName, ...)`
    - `Obj = company(ObjName, ...)`
  - 并按后端需要调整展开方式

这样 Rule 本身仍然是干净模板，但“补全规则”是**可持久化的**，不会隐藏在代码里。

---

## 为什么这个折中是稳妥的
1. **Rule 仍是数据模板**  
   补全逻辑不存储具体 Unify 语句，只存“策略名”。

2. **渲染阶段仍可做差异化**  
   不同后端用不同展开方式，但策略名一致。

3. **可回放**  
   只要有 Rule + expand_policy，就能稳定再现渲染结果。

---

## 如果你接受这个方向，我会做：
1. 给 `Rule` 增加 `expand_policy: Literal[...] = "none"`  
2. 在 renderer 中根据 `expand_policy` 做自动补全  
3. 文档说明这一策略

---

你觉得这个折中可以接受吗？  
如果可以，我就按这个方案改。

> [!note] ME:

我认为可以把subobj_struct本身看作使用结构化的项, 也就是使用Sub, Obj, Since, Title, SubName, SubAddr, SubAge, ObjName这一套命名方法; 否则, 则是相当于只使用一个flat的头, 使用SubName, SubAddr, SubAge, ObjName, Since, Title这一套命名方法, 我使用“Sub”和“Obj”的前缀是担心主语和宾语中使用相同名称的参数的情况. 
也就是说, 本质上我们在使用policy="compound"/"flattened"两种模式, 前者会使用类似:
employment(Sub, Obj, Since, Title) :-
    person(SubName, SubAddr, SubAge),
    company(ObjName),
    Sub = person(SubName, SubAddr, SubAge),
    Obj = company(ObjName),
    // other conditions
的构建逻辑, 后者则采用:
employment(SubName, SubAddr, SubAge, ObjName, Since, Title) :-
    person(SubName, SubAddr, SubAge),
    company(ObjName),
    // other conditions
的构建逻辑, 你怎么看?

> [!warning] CODEX:

我赞同你这个 **compound / flattened** 的两种 policy 设计，逻辑清晰、稳定、也容易渲染。  
要点是：**Rule 仍是数据模板**，只保存 policy 和用户写的部分；渲染阶段根据 policy 生成“补全逻辑”。

下面是我对这两种 policy 的规范化定义（和你描述一致，但更可执行）：

**Policy = `compound`**
- head 变量：`[Sub, Obj] + rel.props`
- body 自动补：
  - `Ref(person, [SubName, SubAddr, SubAge])`
  - `Ref(company, [ObjName, ...])`
  - `Unify(Sub, Ref(person, [SubName, SubAddr, SubAge]))`
  - `Unify(Obj, Ref(company, [ObjName, ...]))`

**Policy = `flattened`**
- head 变量：`[SubName, SubAddr, SubAge, ObjName, ...] + rel.props`
- body 自动补：
  - `Ref(person, [SubName, SubAddr, SubAge])`
  - `Ref(company, [ObjName, ...])`
- 不生成 `Unify`（因为不存在 `Sub/Obj` 变量）

这和你例子完全一致。

---

## 我建议的实现方式（保证 Rule 仍是模板）

1. **Rule 数据只存 policy**
   - `policy="compound" | "flattened" | "none"`
   - 不存自动生成的 `Unify` / `Ref`
2. **渲染前执行 `expand_rule(rule, policy)`**
   - 生成临时结构化 Rule（包含 Unify/Ref）
   - 渲染后丢弃，不写回 Rule

这样 Rule 可持久化且可回放，而补全逻辑统一在代码里。

---

## 需要你确认的 2 个细节

1. **端点变量使用哪些字段？**  
   - A：完整 signature（Name, Addr, Age…）  
   - B：只用 key_fields

2. **变量命名是否固定为 `Sub`/`Obj` + ArgSpec.arg_name？**  
   - 例如 `Name → SubName / ObjName`  
   - 如果有冲突（比如 prop 也叫 Name），是直接报错还是加前缀？

---

如果你确认这两点，我就开始改：  
- 新增 `policy` 字段到 `Rule`  
- 增加 `expand_rule(...)`  
- Renderer 在渲染前自动调用 expand  
- 文档补齐说明


> [!note] ME:

注意看我们的下面这个Rel数据: 
               {'arity': 3,
                 'derived_signature': {'args': [{'arg_name': 'sub_Name',
                                                 'datatype': 'string',
                                                 'namespace': 'person',
                                                 'role': 'sub_key'},
                                                {'arg_name': 'obj_Company',
                                                 'datatype': 'string',
                                                 'namespace': 'org',
                                                 'role': 'obj_key'},
                                                {'arg_name': 'obj_Country',
                                                 'datatype': 'string',
                                                 'namespace': 'geo',
                                                 'role': 'obj_key'}],
                                       'derived': True},

它的arg_name已经都构造成了sub_Name和obj_Company的格式, 我想这给我们省力了, 我们不需要自己改写参数名了, 可以直接使用它的参数名, 但是需要稍作修改:
'derived_signature': {'sub_args': [{'arg_name':'Sub','datatype':'Fact'}, {'arg_name': 'sub_Name', 'datatype': 'string', 'namespace': 'person', 'role': 'sub_key'}, {'arg_name': 'obj_Company', 'datatype': 'string', 'namespace': 'org', 'role': 'obj_key'}],'obj_args':[{'arg_name':'Obj','datatype':'Fact'}, {'arg_name': 'obj_Country', 'datatype': 'string', 'namespace': 'geo', 'role': 'obj_key'}], 'derived': True}
把args拆分成sub_args和obj_args, 并且各自增加一个特殊的参数项"Sub"和"Obj"
此外, 我们也不再使用policy字段了, 而总是沿用Fact和Rel数据的格式, 只是在它们各自的词条下额外增加一个“conditions”词条, 用来放置bodies,

总之任务:
1. 修改Rel类的derived_signature格式, 拆分args
2. 不再使用policy, 而是直接让Rule作为Rel/Fact数据格式下增加新的“conditions”词条,
3. 修改“Body”类的名称为“Cond”, 来适配我们的命名方式

此外保持我们约定的更改建议

> [!warning] CODEX:

已按你的要求改完，关键点如下：

**完成的变更**
1. **Rel 的 `derived_signature` 拆分为 `sub_args/obj_args/prop_args` 并加入 `Sub/Obj`**  
   位置：`/Users/zhenzhili/symbolic_agent/src/symir/ir/fact_schema.py`  
   - 现在 `derived_signature` 结构为：
     - `sub_args`: `Sub` + `sub_*`（来自 sub 的完整 signature）
     - `obj_args`: `Obj` + `obj_*`（来自 obj 的完整 signature）
     - `prop_args`: relation 自身 props  
   - `Sub/Obj` 使用 `datatype="Fact"`  
   - **注意**：`derived_signature` 现在包含 **sub/obj 的完整 signature**（不仅是 key_fields），符合你“端点变量用完整 signature”的要求。

2. **Rule 改为“Fact/Rel 数据格式 + conditions”**  
   位置：`/Users/zhenzhili/symbolic_agent/src/symir/ir/rule_schema.py`  
   - `Rule` 现在是：
     ```python
     Rule(predicate=<Fact/Rel>, conditions=[Cond(...), ...])
     ```
   - `Rule.to_dict()` 输出 **predicate 的 dict + `conditions` 字段**  
   - `Rule.from_dict()` 可直接从这个 payload 反序列化  

3. **`Body` 重命名为 `Cond`**  
   - `Cond` 与旧 `Body` 字段相同（`literals` + `prob`）  
   - 为兼容旧代码，保留了别名 `Body = Cond`

4. **渲染与验证链路已统一为 `conditions`**  
   - 渲染器、验证器、LLM schema 解析、示例和测试全部更新  
   - `Ref` 作为表达式项的能力保留并正常渲染

---

**你要的 Rule 形态已经可持久化**  
`Rule.to_dict()` 现在就是：

```json
{
  "name": "...",
  "kind": "rel/fact",
  ...
  "conditions": [...]
}
```

和你说的一致：**Rule 只存用户定义部分，补全逻辑不写进数据**。

---

## 关键使用方式（更新后的）

```python
from symir.rule_ir import (
    ArgSpec, Fact, Rel, Cond, Rule,
    Var, Ref, Unify
)

person = Fact("person", [ArgSpec("Name:string"), ArgSpec("Addr:string"), ArgSpec("Age:int")])
company = Fact("company", [ArgSpec("Company:string")])

employment = Rel(
    "employment",
    sub=person,
    obj=company,
    props=[ArgSpec("Since:int"), ArgSpec("Title:string")],
)

# conditions 只存用户写的东西
cond = Cond(literals=[
    Ref(predicate=person, terms=[Var("SubName"), Var("SubAddr"), Var("SubAge")]),
    Ref(predicate=company, terms=[Var("ObjName")]),
    Unify(Var("Sub"), Ref(predicate=person, terms=[Var("SubName"), Var("SubAddr"), Var("SubAge")])),
    Unify(Var("Obj"), Ref(predicate=company, terms=[Var("ObjName")])),
])

rule = Rule(predicate=employment, conditions=[cond])
payload = rule.to_dict()
```

---

## 更新涉及文件
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/fact_schema.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/rule_schema.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/mappers/renderers.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/rules/validator.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/rules/constraint_schemas.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/examples/parse_llm_response.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/tests/test_llm_rules.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/tests/test_rule_schema_gen.py`
- `/Users/zhenzhili/symbolic_agent/README.md`

---

如果你希望我再进一步把 **Ref 结构化绑定的自动补全** 变成渲染期策略（而不是用户手写），我可以在 Renderer 里加一个 `expand_rule()` 阶段。只需要你确认触发条件即可。

> [!note] ME:

Ref的payload似乎缺少terms字段, 同时Const不应该再需要datatype参数

> [!warning] CODEX:


已修好两点：

1. **`Const` 不再要求传 `datatype`**  
   - 现在可以直接 `Const("USA")` / `Const(1)`  
   - 会自动推断 `string/int/float/bool`  
   - 如果推断失败就不写 `datatype` 字段

2. **`Ref` 的 payload 现在始终包含 `terms`（在 verbose 模式下）**  
   - `Ref.to_dict()` 本来就会输出 `terms`，我保持并强化了  
   - **结构化输出**里：
     - `mode="verbose"`：`terms` 是必填  
     - `mode="compact"`：用 `args`，不要求 `terms`  

如果你想**强制所有 payload 都包含 `terms`**，请用 `mode="verbose"` 生成/解析。

---

### 你可以直接这样用（datatype 可省略）
```python
from symir.rule_ir import Const, Var, Ref, Unify

expr = Unify(
    Var("Sub"),
    Ref(predicate=person, terms=[Var("SubName"), Const("addr1")])
)
print(expr.to_dict())
```

---

### 改动位置
- `src/symir/ir/expr_ir.py`  
  `Const` datatype 变为 optional + 自动推断
- `src/symir/rules/constraint_schemas.py`  
  `Const/Var` 的 schema 不再要求 `datatype`  
  `Ref` 在 verbose 模式下强制有 `terms`
- `src/symir/examples/parse_llm_response.py`  
  允许常量没有 datatype

---

如果你想“无论 compact/verbose 都强制 terms”，我可以再加一个开关强制输出。


> [!note] ME:

我需要你自动验证Const的数据类型

> [!warning] CODEX:

已加上 **Const 自动类型校验**：

- `Const` 如果未给 `datatype` 会自动推断。
- 如果给了 `datatype`，会验证 **值是否匹配**：
  - `string` → 必须是 `str`
  - `int` → 必须是 `int`（不接受 `bool`）
  - `float` → 接受 `int` 或 `float`（不接受 `bool`）
  - `bool` → 必须是 `bool`
- 非上述类型会跳过验证（保留扩展空间）

修改文件：
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/expr_ir.py`

如果你希望对**未知 datatype 也强校验**，或 `float` 不允许 `int`，告诉我，我再收紧规则。

> [!note] ME:

我的意思是, terms是和谓词的signature一一对应的啊, 所以说可以直接根据signature来验证Const的数据类型是否是正确的啊. 此外Ref中引用一个完整的谓词有点违背我们的设计理念了, 是不是应该只保留kind, negated, schema_id(或其他名称), terms这几项, 然后创建过程中进行数据类型验证

> [!warning] CODEX:

已按你说的思路调整：

**1) `Ref` payload 只保留 `kind / predicate_id / terms / negated`**
- 不再携带完整 predicate 信息。
- `Ref.to_dict()` 永远输出 `terms`。
- 仍允许 `Ref(PredicateSchema, ...)` 这种便利写法，但内部只保存 `predicate_id`。

**2) `Const` 不再要求 `datatype`**
- `Const("USA")` 现在合法。
- 仍可显式传 `datatype`（可选）。

**3) `Const` 类型自动验证（基于 signature）**
- 规则创建后通过 `RuleValidator` 校验：  
  用 `Ref` 的 predicate signature 与 terms 一一对应，验证 `Const.value` 的类型。
- 也会验证 `Ref` 的 arity。

---

## 关键改动位置
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/expr_ir.py`
  - `Ref` 精简为 `predicate_id + terms + negated`
  - `Const.datatype` 变为可选
- `/Users/zhenzhili/symbolic_agent/src/symir/rules/validator.py`
  - 自动按 signature 验证 `Const` 类型
  - 同时校验 `Ref` 的 arity
  - 支持 `Ref` 出现在表达式里（`Unify(Sub, Ref(...))` 也会校验）
- `/Users/zhenzhili/symbolic_agent/src/symir/rules/constraint_schemas.py`
  - `Ref` 的 schema 去掉 predicate 信息
  - `Const/Var` 不再要求 datatype

---

## 使用示例（你要的形式）
```python
from symir.rule_ir import Ref, Const, Var, Cond, Rule, RuleValidator

cond = Cond(literals=[
    Ref(predicate_id=person.schema_id, terms=[Var("X")]),
    Ref(predicate_id=city.schema_id, terms=[Const("USA")]),
])

rule = Rule(predicate=some_pred, conditions=[cond])
RuleValidator(view).validate(rule)  # 这里会自动做类型校验
```

---

如果你希望：
- **构造 `Rule` 时就自动校验**（不需要显式调用 `RuleValidator`），我可以加一个 `Rule.validate(view)` 或 `Rule.__post_init__` 钩子。
- 或者你希望 `Ref` 的字段名改成 `schema_id`（而不是 `predicate_id`），我也可以一起替换。


> [!note] ME:

能不能Cond就自动做类型校验?

> [!warning] CODEX:

可以。`Cond` 现在会在创建时自动做类型校验，但前提是你给它一个 `view`（因为需要 schema 才能验证）。实现已在 `/Users/zhenzhili/symbolic_agent/src/symir/ir/rule_schema.py`。

用法示例（自动验证 arity + Const 类型）：
```python
view = registry.view([person.schema_id, works.schema_id])

cond = Cond(
    literals=[
        Ref(person.schema_id, [Var("X"), Const("alice")]),
        Ref(works.schema_id, [Var("X"), Var("C")]),
    ],
    prob=0.7,
    view=view,  # 传入 view 后自动校验
)
```

如果不传 `view`，`Cond` 无法验证（没有 predicate signature 就无法校验类型）。  
需要的话我也可以加一个 `Rule.from_dict(..., view=...)` 或 `Rule.validate(view)`，让你只传一次 view。

> [!note] ME:

说错了能不能Ref就自动做类型校验? 让schema这里的参数输入一个Fact/Ref的实例, 然后直接根据实例的数据类型进行校验, 是否可行?
    Ref(schema=person, terms=[Var("SubName"), Var("SubAddr"), Var("SubAge")]),

> [!warning] CODEX:

可以。我已经让 `Ref` 在 **传入 `Fact/Rel` 对象时**自动做类型校验（arity + `Const` 类型、以及 `Var.datatype` 的可选校验）。如果只传 `schema_id` 字符串，就不会在 `Ref` 创建时校验（因为没有 signature），这时仍可以用 `Cond(view=...)` 或 `Rule` 的 validator 去统一校验。

现在你可以这样用：

```python
Ref(schema=person, terms=[Var("SubName"), Var("SubAddr"), Var("SubAge")])
```

校验规则：
- `terms` 长度必须等于 `person.arity`
- `Const(...)` 会按 signature 的 datatype 校验
- `Var(datatype=...)` 若设置了，也会和 signature 对比（不填则跳过）

另外我也修了 `Ref` 的反序列化：现在支持 `schema_id` 键（不再只找 `schema`）。

如果你还希望 **在 Ref 创建时强制要求 schema 必须是对象**（禁止 schema_id），我也可以加。


> [!note] ME:

能展示一下各种语法的使用吗? If, Unify等

> [!warning] CODEX:

下面是完整的语法示例（含 `If / Unify / Call / NotExpr / Ref`），按你当前实现给出最小可运行形态。  

```python
from symir.ir.fact_schema import ArgSpec, Fact, Rel
from symir.ir.expr_ir import Var, Const, Ref, Call, Unify, If, NotExpr
from symir.ir.rule_schema import Cond, Rule, ExprLiteral

person = Fact(
    "person",
    [
        ArgSpec("Name:string", namespace="person", role="key"),
        ArgSpec("Age:int", namespace="person"),
    ],
)

company = Fact(
    "company",
    [
        ArgSpec("Company:string", namespace="org", role="key"),
    ],
)

works = Rel(
    "works_at",
    sub=person,
    obj=company,
    props=[
        ArgSpec("since:int", namespace="time"),
        ArgSpec("title:string", namespace="org"),
    ],
)
```

**1) `Ref`（推荐用 schema 对象，会自动校验类型）**
```python
ref1 = Ref(schema=person, terms=[Var("Name"), Const("alice")])
# 如果 Const 类型不匹配，Ref 会抛错

ref2 = Ref(schema=person.schema_id, terms=[Var("Name"), Const("alice")])
# 只传 schema_id 时不会立即校验类型
```

**2) `Unify`**
```python
u = ExprLiteral(
    Unify(
        Var("X"),
        Const("alice"),
    )
)
```

**3) `Call`**
```python
c = ExprLiteral(
    Call("gt", [Var("Age"), Const(18)])
)
# Call 只是一种表达式节点，具体语义由执行器定义
```

**4) `If`**
```python
i = ExprLiteral(
    If(
        cond=Call("gt", [Var("Age"), Const(18)]),
        then=Const(True),
        else_=Const(False),
    )
)
```

**5) `NotExpr`**
```python
n = ExprLiteral(
    NotExpr(Ref(schema=person, terms=[Var("Name"), Const("bob")]))
)

# 或者直接用 Ref(negated=True)
neg_ref = Ref(schema=person, terms=[Var("Name"), Const("bob")], negated=True)
```

**6) `Cond` 与 `Rule`**
```python
cond = Cond(
    literals=[
        Ref(schema=person, terms=[Var("Name"), Var("Age")]),
        Ref(schema=company, terms=[Var("Company")]),
        ExprLiteral(Call("gt", [Var("Age"), Const(18)])),
    ],
    prob=0.7,
)

rule = Rule(
    predicate=works,          # Fact 或 Rel 都可以
    conditions=[cond],
)
```

---

要点说明（避免误用）：
- `Ref` 只接受 `Var` / `Const` 作为 terms。
- `Ref(schema=Fact/Rel)` 会自动校验 arity 和 `Const` 类型；`schema_id` 不会自动校验。
- `ExprLiteral` 是把 `Unify/Call/If/NotExpr` 等表达式塞进 `Cond` 的必要外壳。
- 如果你希望统一校验（即便 `Ref` 只传了 `schema_id`），用 `Cond(view=...)` 或规则验证器即可。

如果你想，我可以补一段“完整 rule 渲染例子”，或者把这些内容写进 README 的规则部分。

> [!note] ME:

能不能把ExprLiteral名字改成Expr

> [!warning] CODEX:


已改名完成：现在用 `Expr`，`ExprLiteral` 保留为兼容别名。

改动点：
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/rule_schema.py` 定义改为 `class Expr`，并保留 `ExprLiteral = Expr` 兼容。
- `/Users/zhenzhili/symbolic_agent/src/symir/rule_ir.py` 导出新增 `Expr`，同时保留 `ExprLiteral`。

用法示例：
```python
from symir.rule_ir import Expr, Call, Var, Const

cond = Cond(literals=[
    Expr(Call("gt", [Var("Age"), Const(18)]))
])
```

我没有跑测试。  
如果你希望彻底移除 `ExprLiteral`（不保留兼容别名），告诉我。


> [!note] ME:

我希望彻底移除 ExprLiteral（不保留兼容别名）

> [!warning] CODEX:

Done. `ExprLiteral` is fully removed (no alias), and everything now uses `Expr`.

Changes applied:
- Removed `ExprLiteral` alias in `/Users/zhenzhili/symbolic_agent/src/symir/ir/rule_schema.py`.
- Updated all references across code/docs/tests to `Expr`.
- Renamed internal schema wrapper `ExprLiteralModel` → `ExprWrapperModel` to eliminate the string entirely.

Breaking change note:
- Any code importing or calling `ExprLiteral` must switch to `Expr`.

If you want a different internal name than `ExprWrapperModel`, tell me and I’ll change it.
