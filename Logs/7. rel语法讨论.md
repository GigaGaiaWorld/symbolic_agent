
> [!note] ME:

Instance(
    schema=works_at,
    terms={
        "sub_key": {"Name": "bob"},
        "obj_key": {"Company": "openai"},
        "props": {"since": 2020, "title": "researcher"},
    },
)

似乎并不支持这种定义而是应使用:
works_at_fact = Instance(
    schema=works,
    terms={
        "sub_key": {"Name": "bob"},
        "obj_key": {"Company": "openai"},
        "since": 2020, "title": "researcher",
    },
)



> [!warning] CODEX:

是支持的。`terms` 里包含 `sub_key` / `obj_key` / `props` 这种形式在当前实现中是合法的。  
如果你遇到“不支持”的报错，**最常见原因**是端点 key 名字不匹配（不是语法问题）。

**重点检查：**
- `sub_key` / `obj_key` 的字段名必须 **严格等于** `Rel.endpoints.sub_key_fields` / `obj_key_fields` 里的 key。
- `props` 里的字段名必须 **严格等于** `Rel.props` 的 `arg_name`。

举例：如果 `company` 的 key 字段默认是 `"Name"`，那这里必须是：

```python
Instance(
    schema=works,
    terms={
        "sub_key": {"Name": "bob"},
        "obj_key": {"Name": "openai"},
        "props": {"since": 2020, "title": "researcher"},
    },
)
```

你写的 `{"Company": "openai"}` 只有在 **company 的 key 字段就是 `"Company"`** 时才成立。  
要这样用，需要在 `company` schema 里把 key 定义成 `"Company"`：

```python
company = Fact(
    "company",
    [ArgSpec("Company:string", role="key"), ArgSpec("worth:float")],
)
```

**你也可以用扁平 dict**（两种都支持）：
```python
Instance(
    schema=works,
    terms={
        "Name": "bob",          # sub key
        "Company": "openai",    # obj key (前提：key_fields 里确实叫 Company)
        "since": 2020,
        "title": "researcher",
    },
)
```

如果你愿意，我可以加一个帮助函数或错误提示，把“期望的 sub/obj key 字段名”写得更明确。




> [!note] ME:

---------------------------------------------------------------------------
SchemaError                               Traceback (most recent call last)
 ...
SchemaError: Unknown rel props: ['since', 'title']

> [!warning] CODEX:

报错原因不是 `sub_key/obj_key/props` 形式不支持，而是 **`works` 的 `props` 定义和你传入的字段不匹配**。在 strict 模式下，`props` 里的字段名必须严格等于 `Rel.props` 里定义的 `arg_name`。

**最常见两种情况：**

1) `works` 根本没有定义 props  
你可能是这样定义的：
```python
works = Rel("works_at", sub=person, obj=company)
```
那 `props` 里任何字段都会被视为未知 → 报错。

2) `props` 定义了，但名字不是 `"since"`/`"title"`  
比如你用了 `ArgSpec("int")`、`ArgSpec("string")`，那么默认 `arg_name` 会变成 `Param`/`Param2`，而不是 `since`/`title`。

---

## 正确做法

### 如果你想用 `since`/`title`：
```python
works = Rel(
    "works_at",
    sub=person,
    obj=company,
    props=[
        ArgSpec("since:int", namespace="time"),
        ArgSpec("title:string", namespace="org"),
    ],
)
```

然后你的写法就是合法的：
```python
Instance(
    schema=works,
    terms={
        "sub_key": {"Name": "bob"},
        "obj_key": {"Name": "openai"},
        "props": {"since": 2020, "title": "researcher"},
    },
)
```

---

## 快速自检
```python
[p.arg_name for p in works.props]           # 应该是 ["since", "title"]
works.endpoints                             # 看 sub/obj key 字段
```

---

如果你愿意，我可以把报错信息改得更直白，例如：

```
Unknown rel props: ['since', 'title'].
Expected props: ['Param', 'Param2'] (from works_at.props)
```

这样你一看就能知道该用什么字段名。




> [!note] ME:

Instance(
    schema=works,
    terms={
        "sub_key": {"Name": "bob"},
        "obj_key": {"Name": "openai"},
        "props": {"since": 2020, "title": "researcher"},
    },
)

我尝试了但是仍有错误, 具体你为什么认为是支持这种写法? 有什么证据?




> [!warning] CODEX:

是支持的，证据就在实现里。

**证据（代码路径）**  
在 `/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py#L417` 之后，`_parse_rel_terms_dict` 明确处理了 `sub_key/obj_key/props` 形式：  
- 读取 `terms["props"]`  
- 在 strict 模式下，校验 `props` 里每个字段名必须在 `schema.props` 里  
- 然后继续解析端点

对应代码片段：  
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py#L417-L446`

你报错 `Unknown rel props: ['since', 'title']` 说明：
- 这个分支被执行了（所以“支持 props”是事实）
- **但 `works.props` 里没有 `since` / `title`**，所以严格校验失败

---

## 你需要确认的关键点

请在你的环境里直接打印：

```python
[p.arg_name for p in works.props]
works.to_dict()["props"]
```

如果输出不是 `["since", "title"]`，那就是 schema 定义的问题，不是 terms 的问题。

---

## 正确 schema 定义（能通过）

```python
works = Rel(
    "works_at",
    sub=person,
    obj=company,
    props=[
        ArgSpec("since:int"),
        ArgSpec("title:string"),
    ],
)
```

然后你写的就会成功：

```python
Instance(
    schema=works,
    terms={
        "sub_key": {"Name": "bob"},
        "obj_key": {"Name": "openai"},
        "props": {"since": 2020, "title": "researcher"},
    },
)
```

---

如果你愿意，把 `works` 的定义贴出来，我可以直接指出具体哪里不匹配。




> [!note] ME:

现在是否不支持直接使用instance作为sub_key和obj_key?
Instance(
    schema=works_at,
    terms={
        "sub_key": bob,
        "obj_key": openai,
        "props": {"since": 2020, "title": "researcher"},
    },
)



> [!warning] CODEX:

目前**不支持**把 `Instance` 直接放在 `sub_key` / `obj_key` 里。  
证据：在解析 `terms` 的分支里，`sub_key/obj_key` **强制要求是 dict**，否则直接报错。  
代码位置：`/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py#L417-L421`

```python
if "sub_key" in terms or "obj_key" in terms:
    sub_key = terms.get("sub_key")
    obj_key = terms.get("obj_key")
    if not isinstance(sub_key, dict) or not isinstance(obj_key, dict):
        raise SchemaError("Rel dict terms require sub_key and obj_key dicts.")
```

**你可以这样写（已支持）：**

1) 用 `sub_ref` / `obj_ref`（支持 `Instance`）  
```python
Instance(
    schema=works_at,
    terms={
        "sub_ref": bob,
        "obj_ref": openai,
        "props": {"since": 2020, "title": "researcher"},
    },
)
```

2) 用 list/tuple（端点直接写 `Instance`）  
```python
Instance(
    schema=works_at,
    terms=[bob, openai, 2020, "researcher"],
)
```

---

如果你想让 `sub_key/obj_key` 也接受 `Instance`（或 `InstanceRef`），我可以改解析逻辑，让它自动把 `Instance` 当作 endpoint。要我改吗？



> [!note] ME:

Instance(
    schema=works_at,
    terms={
        "sub_ref": bob,
        "obj_ref": openai,
        "props": {"since": 2020, "title": "researcher"},
    },
)

这个不支持是吗



> [!warning] CODEX:


支持。`sub_ref` / `obj_ref` 这条路径就是为 `Instance` 设计的。证据在代码里：  
`/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py#L386-L416`

**支持前提**（否则会报错）：
1. `bob` / `openai` 必须是 **fact** `Instance`（不是 rel）。  
2. 它们的 `schema_id` 必须分别匹配 `works_at.sub_schema_id` / `works_at.obj_schema_id`。  
3. `bob` / `openai` 必须已有 `entity_id`（fact instance 会自动生成）。  
4. strict 模式下，`bob.props` / `openai.props` 必须包含对应 key_fields。

**正确示例**
```python
bob = Instance(schema=person, terms={"Name": "bob"})
openai = Instance(schema=company, terms={"Name": "openai"})

rel = Instance(
    schema=works_at,
    terms={
        "sub_ref": bob,
        "obj_ref": openai,
        "props": {"since": 2020, "title": "researcher"},
    },
)
```

如果你仍然报错，把完整错误贴出来，我可以精确定位是哪个条件没满足。




> [!note] ME:

Instance(
    schema=works_at,
    terms={
        "sub_ref": bob,
        "obj_ref": openai,
        "props": {"since": 2020, "title": "researcher"},
    },
)
---------------------------------------------------------------------------
SchemaError                               Traceback (most recent call last)
	......
SchemaError: Unknown rel props: ['props']

> [!warning] CODEX:

已修复你遇到的情况。现在 `sub_ref/obj_ref` 形式支持同时携带 `"props": {...}`。

你原来的写法现在可以正常工作：

```python
Instance(
    schema=works_at,
    terms={
        "sub_ref": bob,
        "obj_ref": openai,
        "props": {"since": 2020, "title": "researcher"},
    },
)
```

修改点在：
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py`  
  现在会把 `props` 从 dict 中单独解析出来，不再误判为未知字段。

如果你希望，我还可以把错误提示增强成“期望 props 列表 + 实际 props 列表”，方便排查。




> [!note] ME:

把这些feature都加到README里呀, 要不然用户怎么知道能做什么



> [!warning] CODEX:


已把 Instance 的完整用法和所有输入形态写进 `IR` README，包括：

- `schema` vs `schema_id + registry`
- fact/rel 的 `terms` 解析规则
- rel 的三种 dict 形式（`sub_ref/obj_ref` + props、`sub_key/obj_key` + props、扁平 dict）
- list/tuple 形式
- strict/heuristic
- `merge_policy` 与 `record_id`

文件：`/Users/zhenzhili/symbolic_agent/src/symir/ir/README.md`

如果你还希望把这段同步到根目录 `README.md`，告诉我。




> [!note] ME:

此次更新还增加了什么功能和features?

> [!warning] CODEX:

这次更新新增/改动的功能要点如下（只列功能层面）：

1. **统一 Instance 系统**
   - 新增 `Instance` 类型，统一表示 fact/rel（不再区分 FactInstance/RelInstance）。
   - 支持 `schema` 或 `schema_id + registry` 创建。
   - canonical 输出包含 `schema_id` + `entity_id/sub_entity_id/obj_entity_id` + `props` + `prob` + `meta`。
   - 支持 `merge_policy="keep_all"` 自动生成 `record_id`。

2. **rel 端点与 props 多种输入形式**
   - list/tuple：`[sub, obj, ...props]`
   - dict 形式：
     - `sub_ref/obj_ref + props`
     - `sub_key/obj_key + props`
     - 扁平字段（CSV 友好）
   - `sub_ref`/`obj_ref` 支持直接传 `Instance`。

3. **CSVProvider 返回 Instance**
   - CSV 读取直接产出 `Instance`，而不是旧的 `FactInstance`。
   - `Renderer` 兼容新 `Instance`（使用 `to_terms` 生成输出）。

4. **Registry API 增强（之前已做）**
   - `fact(name)` / `rel(name)` / `resolve(kind, name)` / `rel_of_ids(...)`
   - `facts()` / `rels()` / `names()` / `describe(schema_id)`
   - `to_dict()` 带 `version` 与稳定排序；`from_dict()` 校验版本和 schema_id 一致性。

5. **文档补充**
   - 新增 `/src/symir/ir/README.md`：完整 Instance 教程
   - 新增 `/src/symir/fact_store/README.md`：CSVProvider 与旧 CsvFactStore 说明
   - README 中更新导入示例，去掉 `FactInstance`

如果你想要“变更清单”形式（按文件逐条），我也可以给你列一个更细的。





> [!note] ME:

有没有更新如何merge的逻辑?



> [!warning] CODEX:

没有。  
这次只是**让 Instance 记录 `meta.merge_policy` 并在 `keep_all` 时生成 `record_id`**。真正的合并策略（`max/latest/noisy_or/overwrite/keep_all` 的落库行为）**尚未实现**，也没有新增 merge executor。  

如果你希望我补“合并层”逻辑（比如在 fact_store 或单独的 merger 模块里），告诉我合并的输入/输出形态以及落库方式，我可以继续做。

