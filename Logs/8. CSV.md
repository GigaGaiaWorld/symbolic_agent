
> [!note] ME:

CSVProvider如何使用?

> [!warning] CODEX:

下面是**CSVProvider 的最小完整用法**（基于 `Fact/Rel` schema）。

**1) 定义 schema**
```python
from pathlib import Path
from symir.ir.fact_schema import ArgSpec, Fact, Rel, FactLayer
from symir.fact_store.provider import CSVProvider, CSVSource

person = Fact("person", [ArgSpec("Name:string", role="key"), ArgSpec("address:string")])
city = Fact("city", [ArgSpec("Name:string", role="key"), ArgSpec("Country:string")])
lives_in = Rel("lives_in", sub=person, obj=city, props=[ArgSpec("since:int")])

schema = FactLayer([person, city, lives_in])
```

**2) 配置 CSVSource**
`CSVSource.columns` 必须和 **schema 的 signature 顺序一致**：

- Fact：`Fact.signature` 顺序
- Rel：`Rel.derived_signature` 顺序（sub_* / obj_* + props）

```python
sources = [
    CSVSource(
        predicate_id=person.schema_id,
        file="people.csv",
        columns=["Name", "address"],
    ),
    CSVSource(
        predicate_id=city.schema_id,
        file="cities.csv",
        columns=["Name", "Country"],
    ),
    CSVSource(
        predicate_id=lives_in.schema_id,
        file="lives_in.csv",
        columns=["sub_Name", "obj_Name", "since"],
    ),
]
```

**3) 读取**
```python
provider = CSVProvider(schema=schema, base_path=Path("data"), sources=sources)

# view 决定允许加载哪些 schema
view = schema.view([p.schema_id for p in schema.predicates()])
instances = provider.query(view)
```

**4) CSV 文件示例**
`data/people.csv`
```
Name,address
alice,darmstadt
bob,frankfurt
```

`data/cities.csv`
```
Name,Country
darmstadt,germany
frankfurt,germany
```

`data/lives_in.csv`
```
sub_Name,obj_Name,since
alice,darmstadt,2020
bob,frankfurt,2021
```

**5) 输出**
`instances` 是 `Instance` 列表，每一行 CSV 对应 1 个 `Instance`。

---

如果你希望 `CSVProvider` 支持“扁平 dict”或自动匹配列名到 key_fields，我也可以扩展。

> [!note] ME:

你觉得Factview应该和registry合并吗? 即view也是FactLayer格式?

> [!warning] CODEX:


短答案：**不建议“硬合并”，但建议让 `FactView` 暴露与 `FactLayer` 同一套只读 API**，用起来就像一个“子注册表”。

**理由**
- `FactLayer` 是权威 registry；`FactView` 本质是“允许集合/过滤视图”。  
- 合并会迫使你在每个 view 都重新建索引、重复校验；代价不大，但语义上混乱（view 不是权威来源）。
- 如果把 `FactLayer` 做成可选 “schema_ids 限制”，最终还是会回到“有一个基表 + 一个允许集合”的结构，本质上就是 `FactView`。

**我建议的方向**
- 保留 `FactView`，但实现与 `FactLayer` 相同的接口：  
  `predicates() / facts() / rels() / get() / fact() / rel() / resolve() / names() / describe()`  
  这些方法只对 view 内的 schema 生效。  
- 这样调用方不用关心是 view 还是 layer，接口一致。

**如果你坚持要合并**
- 可以让 `FactLayer` 接受可选 `schema_ids`，并在所有查找上做 allowlist 过滤。  
- 但这会让 `FactLayer` 同时承担“registry + view”的双重语义，边界不清。

如果你想，我可以按“保持 `FactView`，但 API 对齐 `FactLayer`”的方案改。  
你更偏向哪种？



> [!note] ME:

因为很多时候, 我希望view和layer能同样使用于一些函数例如这里的CSVProvider, 它们应该能同样被使用

> [!warning] CODEX:

已按你的需求实现：**FactView 与 FactLayer 可在 CSVProvider 等函数中“等价使用”**，并补充了文档。

**改动内容**
1. `FactView` 现在提供与 `FactLayer` 同样的只读接口  
   `get / fact / rel / resolve / facts / rels / names / describe`  
   文件：`/Users/zhenzhili/symbolic_agent/src/symir/ir/fact_schema.py`

2. `CSVProvider` 支持传入 `FactLayer` 或 `FactView`  
   - 若传入 `FactView`，它会作为默认 view  
   - `query()` 现在可不传参数（会使用默认 view 或全量 schema）  
   文件：`/Users/zhenzhili/symbolic_agent/src/symir/fact_store/provider.py`

3. 文档更新  
   - `fact_store/README.md` 补充 “view 也可以作为 schema 使用”的示例  
   文件：`/Users/zhenzhili/symbolic_agent/src/symir/fact_store/README.md`

如果你还希望 **Renderer/RuleValidator/其他 API** 也接受 `FactView` 直接使用，我可以继续扩展。

> [!note] ME:

sources = [
    CSVSource(
        predicate_id=person.schema_id,
        file="people.csv",
        columns=["Name", "address"],
    ),
    CSVSource(
        predicate_id=city.schema_id,
        file="cities.csv",
        columns=["Name", "Country"],
    ),
    CSVSource(
        predicate_id=lives_in.schema_id,
        file="lives_in.csv",
        columns=["sub_Name", "obj_Name", "since"],
    ),
]

CSVSource是否仍然支持prob_columns

> [!warning] CODEX:

支持，`CSVSource` 仍然有 `prob_column` 字段。  
用法示例：

```python
CSVSource(
    predicate_id=person.schema_id,
    file="people.csv",
    columns=["Name", "address"],
    prob_column="prob",
)
```

如果 `prob_column` 不存在或为空，会走默认概率策略。




> [!note] ME:

ProviderError(f"Missing CSV source mapping for schema_id: {schema_id}")
我认为在error中只给出id会很迷惑性

> [!warning] CODEX:

已改进错误信息，现在会包含**schema 名称**和**当前已映射的 sources 列表**，避免只看到 id 迷惑。

触发位置：`/Users/zhenzhili/symbolic_agent/src/symir/fact_store/provider.py`

示例错误格式：
```
Missing CSV source mapping for schema_id: <id> (name=<predicate_name>). Mapped sources: name1:id1, name2:id2
```

如果你想进一步把 view/allowed 的列表也打印出来，我也可以加。

> [!note] ME:

为什么要给出当前已映射的 sources 列表, 不必要吧?

> [!warning] CODEX:

同意，已去掉 “已映射 sources 列表”。  
现在错误只包含 `schema_id` + `name`，更简洁。

文件：`/Users/zhenzhili/symbolic_agent/src/symir/fact_store/provider.py`

如果你还想加别的提示（例如“请检查 CSVSource 是否包含该 schema_id”），告诉我。


> [!note] ME:

还记得我们说过如何导入csv吗? 实际上是如何实现的?

> [!warning] CODEX:

下面是**CSV 导入的实际实现**（当前代码里真的怎么做的），对应你之前讨论的“CSV → Instance 逐行落地”。

**实现位置**
- 主要逻辑：`/Users/zhenzhili/symbolic_agent/src/symir/fact_store/provider.py`
- 旧版 CSV 映射（非 Fact/Rel）：`/Users/zhenzhili/symbolic_agent/src/symir/fact_store/csv_store.py`（这是旧的 mapping schema，不是现在的 Fact/Rel）

---

## CSVProvider 的真实执行流程

**1) 初始化**
```python
provider = CSVProvider(schema=<FactLayer 或 FactView>, base_path=Path(...), sources=[...])
```
- `sources` 会变成 `{predicate_id: CSVSource}` 的映射。
- 如果传入 `FactView`，会作为默认 view（`query()` 不传参数时使用）。

---

**2) 查询时的行为**
`query(view=None, filt=None)` 的行为：

1. 决定允许的 schema_id 集合  
   - 如果给了 `view` 用它  
   - 否则用默认 view 或全量 schema
2. 如果有 `filt`，就在这些 predicate 上做二次过滤  
3. 对每个允许的 schema_id：
   - 必须在 `sources` 中存在，否则报错（错误包含 `schema_id + name`）
   - 调 `_load_source` 读取 CSV

---

**3) 读取 CSV（_load_source）**

- `csv.DictReader` 读入
- header 做 strip 规范化
- 检查 `CSVSource.columns` 全部存在
- 每行：
  - 逐列读取（按 `CSVSource.columns` 顺序）
  - 用 `_coerce_value()` 处理  
    - 当前只做**空值检查+strip**，**不会按 datatype 自动转换**
  - 构造 `terms` 为 dict：`{arg_spec.name: value}`
  - 计算 `prob`（如果有 `prob_column`，会 `float()` + 概率策略）
  - 最后生成 `Instance(schema=pred_schema, terms=terms, prob=prob)`

也就是说：**CSV 一行 = 一个 Instance**。

---

## Rel 的 CSV 映射方式（实际规则）

CSVProvider 直接使用 **`Rel.signature`（derived_signature）** 作为列名顺序。  
这就是为什么你要写 `sub_*` / `obj_*`：

```python
CSVSource(
    predicate_id=lives_in.schema_id,
    file="lives_in.csv",
    columns=["sub_Name", "obj_Name", "since"],
)
```

`Instance` 会把：
- `sub_Name` 归到 sub 端 key  
- `obj_Name` 归到 obj 端 key  
- 其余字段归到 rel props

---

## 关键限制（当前实现真实状态）

- **不会按 datatype 自动转换**（`int/float` 仍是字符串）  
  如果你需要严格类型转换，需要加一层转换逻辑。
- strict 校验会在 `Instance` 内执行：
  - key_fields 必须存在
  - prop 名称必须匹配
  - rel 端点 key 必须齐全

---

如果你希望我把 **CSVProvider 增加 datatype cast**（根据 `ArgSpec.datatype`），或者允许更灵活的列名映射，我可以直接改。

> [!note] ME:

datatype cast作为一个选项可以吗?

> [!warning] CODEX:

可以，但在动手改之前需要你确认具体方案。

我建议这样做（默认不改变现有行为）：

**方案（推荐）**
- 在 `CSVProvider` 增加参数 `datatype_cast`，默认 `"none"`。
- 可选值：`"none" | "coerce" | "strict"`  
  - `none`：保持现状，全部按字符串  
  - `coerce`：识别 `int/float/bool/string`，能转就转；未知 datatype 仍保留字符串  
  - `strict`：遇到未知 datatype 或转换失败直接报错

**你确认后我会做：**
1. 实现 `datatype_cast` 选项  
2. 增加基本转换规则（int/float/bool）  
3. 更新 README（CSVProvider 用法）

请告诉我你选哪种：  
1) `datatype_cast="coerce"`（推荐）  
2) `datatype_cast="strict"`  
3) 只加 `bool` 选项（true/false）更简化



> [!note] ME:

可选值："none" | "coerce" | "strict"

> [!warning] CODEX:

已按你的规范实现 `datatype_cast` 选项（`"none" | "coerce" | "strict"`）：

**实现内容**
- `CSVProvider` 新增参数 `datatype_cast`，默认 `"none"`  
- `"coerce"`：对 `int/float/bool` 做尽力转换  
- `"strict"`：类型不匹配或未知 datatype 直接报错  
- `bool` 支持：`true/false/1/0/yes/no`（不区分大小写）

**文件**
- `/Users/zhenzhili/symbolic_agent/src/symir/fact_store/provider.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/fact_store/README.md`（已补充用法）

**用法示例**
```python
provider = CSVProvider(
    schema=schema,
    base_path=Path("data"),
    sources=sources,
    datatype_cast="coerce",  # none | coerce | strict
)
```

如果你希望 `bool` 只接受 `true/false`，或支持更多 datatype（如 date/datetime），告诉我我可以收紧/扩展。
