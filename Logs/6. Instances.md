
> [!note] ME:

接下来我们对Instance部分进行优化, 

### 1. 目标与原则

1. Instance 是系统最终的事实表达方式。任何从 CSV/数据库/用户输入/规则生成的事实，最终必须落成**逐条 Instance**（不存在一个 Instance 表示多个实例集合的语义）。

2. 创建 Instance 时允许用户使用 `schema`（Fact/Rel 对象）或 `schema_id`。
   之所以允许传 `schema` 对象，是因为创建阶段需要用 schema 的 `signature/key_fields/endpoints/props` 做解析、校验与 ID 生成。
   但**最终落盘/序列化时只保留 `schema_id`**，不保留对象引用。

3. 统一只使用一个 `Instance` 类型，不拆成 FactInstance/RelInstance。
   由 `schema` 的 kind（fact/rel）决定解析与校验逻辑。

4. 默认 strict：一旦传入 schema（或 schema_id 可解析到 schema），就必须按 schema 解析与验证；不满足即报错。
   （如需启发式自动匹配，必须显式开启，默认关闭。）

---

### 2. 创建方式（示例）

```python
alice = Instance(schema=person, terms=["alice", "darmstadt"], prob=0.9)
darmstadt = Instance(schema=city, terms=["darmstadt", "germany"])

facts_from_user = [
    alice,
    Instance(schema=person, terms=["bob", "frankfurt"], prob=0.8, meta=...),
    Instance(schema=city.schema_id, terms=["seattle", "usa"], prob=0.95),
    Instance(schema=company, terms=["openai", 10.0]),
    Instance(schema=country, terms=["usa", 1776]),

    # rel：用实例引用作为端点（交互输入）
    Instance(schema=registry.resolve("rel", "lives_in"), terms=[alice, darmstadt]),

    # rel：不要默认启发式猜测端点；请用可判定端点形式（见下文）
    # 例如：端点用 key dict（CSV/外部输入友好）
    Instance(
        schema=registry.rel_of_ids("works_at", person.schema_id, company.schema_id),
        terms=[{"Name": "bob"}, {"Company": "openai"}]
    ),
]
```

---

### 3. 元数据（meta）约定

Instance 支持工程常用元数据以便：回滚、再摄取、冲突解决、按来源删除、时间切片查询等。

推荐 meta 字段（均不参与 entity_id/端点 id 的哈希）：

* `source`: 数据来源（csv/database/user/api/rule…）
* `observed_at`: 数据源侧观测时间
* `ingested_at`: 进入系统时间（建议系统填）
* `confidence`: 来源可靠性
* `status`: `"asserted"|"inferred"|"retracted"`（撤回应定义为软删除语义更稳）
* `evidence_id`: 证据稳定 ID（行 hash/文档片段 id/数据库主键等）
* `trace_id`: 一次导入/任务追踪 id
* `provenance`: 结构化溯源（不要放大文本）
* `tags`: 标签（筛选/审计）

合并策略相关：

* `merge_policy`: `"max"|"latest"|"noisy_or"|"overwrite"|"keep_all"`

---

### 4. 输入 terms 的支持形态（统一入口）

输入参数名统一为 `terms`。`terms` 可以是 `list/tuple/dict`。

#### 4.1 fact：terms 解析规则

* 若 `terms` 是 `list/tuple`：按 `Fact.signature` 的顺序映射为 `props(dict)`
  例如 `person_profile(Name, Address, Age)`：`["alice","darmstadt",23] -> {"Name":"alice","Address":"darmstadt","Age":23}`
* 若 `terms` 是 `dict`：视为 `props(dict)`（字段名必须匹配 signature，strict 下不允许多余字段）

#### 4.2 rel：terms 解析规则（强制“前两项为端点”）

rel 的 `terms` 推荐使用 `list/tuple`（最清晰），也支持 `dict`（适合 CSV 映射）。

A) `terms` 为 `list/tuple`（推荐）

* 强制：`len(terms) >= 2`
* 端点：

  * `terms[0]` 表示 sub
  * `terms[1]` 表示 obj
* 关系属性：

  * `terms[2:]` 表示关系自有属性值，**严格按 `Rel.props` 的顺序**映射成 `props(dict)`
  * strict 默认：必须满足 `len(terms[2:]) == len(Rel.props)`，否则报错
    （若未来要允许缺省，必须额外定义缺省策略；目前先不做）

端点项允许两种“可判定”类型（建议都支持）：

1. **Instance 引用（交互输入）**

   * `terms[0]`、`terms[1]` 为 fact Instance
   * 要求：端点必须能得到稳定 `entity_id`：

     * 若该 fact Instance 已 canonical（有 entity_id），直接使用；
     * 否则若其 key_fields 在其 props 中齐全，允许当场计算 entity_id；
     * 否则报错。

2. **key dict（CSV/外部输入）**

   * `terms[0]` 是 dict，且覆盖 `Rel.endpoints.sub_key_fields`
   * `terms[1]` 是 dict，且覆盖 `Rel.endpoints.obj_key_fields`
   * 用它们按规则计算端点 id（见 5）

默认不允许启发式猜测：

* 如果 `terms[0]/terms[1]` 是裸字符串/数字且没有字段名（无法判定它属于哪个 key_field），**直接报错**
* 除非显式开启 `resolve_mode="heuristic"`（默认关闭，不推荐作为主路径）

B) `terms` 为 `dict`（适合 CSV 映射）
rel 的 dict 输入允许三种等价形式之一（严格不猜）：

1. 引用式：

```python
{"sub_ref": <fact Instance>, "obj_ref": <fact Instance>, ...<rel_props_fields>...}
```

2. 分离 key：

```python
{"sub_key": {...}, "obj_key": {...}, "props": {...}}
```

3. 扁平字段（最适合 CSV 行 dict）：

* dict 同时包含 sub_key_fields、obj_key_fields、rel.props 字段
* 解析时严格按 endpoints/props 拆分（字段归属由 schema 决定，不允许猜）

---

### 5. 校验与 canonicalize（默认 strict）

一旦 schema 可用（schema 对象或 schema_id 可解析），创建时立即执行校验与 canonicalize。

#### 5.1 fact：校验与 entity_id 生成

校验（strict）：

* `Fact.key_fields` 必须全部存在，否则报错
* 字段名必须属于 `Fact.signature`（strict）；lenient 才允许额外字段

canonicalize：

* `key_props = {k: props[k] for k in Fact.key_fields}`（按 key_fields 顺序）
* `entity_id = H(Fact.schema_id + canonical_json(key_props))`

输出 canonical：`schema_id, kind, entity_id, props, prob, meta`

#### 5.2 rel：校验与端点 id 生成

校验（strict）：

* 必须能得到 sub_key/obj_key（来自 InstanceRef 或 key dict/扁平 dict）
* sub_key 必须覆盖 `Rel.endpoints.sub_key_fields`
* obj_key 必须覆盖 `Rel.endpoints.obj_key_fields`
* 关系属性字段必须属于 `Rel.props`（strict 下不允许多余字段）
* list/tuple 输入时：`len(terms[2:]) == len(Rel.props)`（默认 strict）

canonicalize：

* `sub_entity_id = H(Rel.sub_schema_id + canonical_json(ordered(sub_key_props)))`
* `obj_entity_id = H(Rel.obj_schema_id + canonical_json(ordered(obj_key_props)))`

输出 canonical：`schema_id, kind, sub_entity_id, obj_entity_id, props, prob, meta`
（keep_all 时额外见 6）

> 注：`kind` 若存储，必须与 registry.get(schema_id).kind 一致；冲突则报错。
> `kind` 不参与任何哈希/id 计算。

---

### 6. prob 与多证据合并（merge_policy）

* `prob` 始终允许存储。合并策略做成可插拔选项，但必须明确存储层表现。
* 最小公共接口：`meta.merge_policy ∈ {max, latest, noisy_or, overwrite, keep_all}`

关键约束：`keep_all` 必须可幂等

* `keep_all` 时必须生成 `record_id`（建议放在 **顶层字段**，便于写库/去重）：

  * 推荐：`record_id = H(schema_id + sub_entity_id + obj_entity_id + evidence_id)`
  * 若缺 `evidence_id`：使用固定规则组合替代（例如 canonical(props)+source+observed_at），但必须统一实现并写入文档。

---

### 7. CSV 生成 Instance（逐行落地）

CSV 读取不产生集合 Instance。每行映射成 1..N 条 Instance。

* 因为 CSV 不存在“一列是一个 Fact”的天然语义，可使用条件语句/映射规则：

  * 给定 schema
  * 指定 sub、obj、rel.props 的列映射方式（相当于 Neo4j 生成规则的 mapping）
  * 允许不提供完整属性：fact 可只提供 key_fields；rel 可只提供端点 key（props 可为空或缺省但需符合 strict 策略）

推荐 CSV → rel 使用：

* `terms` dict 的“扁平字段”形式，或 list 形式里端点用 key dict（见 4.2）

---

### 8. 统一 JSON 形状（canonical 输出）

公共字段（总是存在）：

* `schema_id: str`
* `kind: "fact" | "rel"`（可选冗余；不参与哈希；与 registry 不一致则报错）
* `props: dict`（canonical 后总是 dict）
* `prob: float | None`
* `meta: dict`

fact 特化字段：

* `entity_id: str`（必填）

rel 特化字段：

* `sub_entity_id: str`（必填）
* `obj_entity_id: str`（必填）
* `record_id: str`（仅当 `meta.merge_policy == "keep_all"` 时必填，推荐顶层）

---

### 9. 最终数据示例（rel canonical）

```json
{
  "schema_id": "dc708f907ac5a9eb3aba5ba6d45940cd756a409e52cbc7e1d79a9a6040832fc6",
  "kind": "rel",
  "sub_entity_id": "H(<sub_schema_id> + {'Name':'alice'})",
  "obj_entity_id": "H(<obj_schema_id> + {'Company':'openai'})",
  "props": {
    "since": 2020,
    "title": "researcher"
  },
  "prob": 1.0,
  "meta": {
    "source": "user",
    "observed_at": "2026-02-10T18:03:00Z",
    "ingested_at": "2026-02-10T18:03:12Z",
    "evidence_id": "sha256:1f2c...9a0b",
    "trace_id": "run_20260210_001",
    "confidence": 0.82,
    "status": "asserted",
    "tags": ["imported", "manual_ok"],
    "merge_policy": "keep_all"
  },
  "record_id": "H(schema_id + sub_entity_id + obj_entity_id + evidence_id)"
}
```

最终请在fact_store文件夹下创建README文档.





> [!warning] CODEX:

已完成 Instance 体系改造并新增 `fact_store` README。关键点如下：

**完成的修改**
1. 新增统一 `Instance` 类型（严格解析+canonicalize），支持 `schema` 或 `schema_id`（需 registry 解析），支持 fact/rel 全部规则与 `keep_all` 的 `record_id` 生成。  
   文件：`/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py`
2. CSVProvider 现在直接输出 `Instance`；Renderer 也改为消费 `Instance`。  
   文件：  
   - `/Users/zhenzhili/symbolic_agent/src/symir/fact_store/provider.py`  
   - `/Users/zhenzhili/symbolic_agent/src/symir/mappers/renderers.py`
3. 对外导出与文档同步更新（`rule_ir`/README）。  
   文件：  
   - `/Users/zhenzhili/symbolic_agent/src/symir/rule_ir.py`  
   - `/Users/zhenzhili/symbolic_agent/src/README.md`
4. 新增 `fact_store/README.md`。  
   文件：`/Users/zhenzhili/symbolic_agent/src/symir/fact_store/README.md`

**你需要知道的行为点**
- 用 `schema_id` 构造 `Instance` 时必须传 `registry`，否则会报错（因为无法解析 signature/key_fields）。
- `Instance.to_dict()` 只输出 canonical 字段（不包含端点 key props）。  
  这意味着：如果你从 JSON 反序列化得到的 rel instance 没有端点 key props，`to_terms()` 将无法重建 derived signature（会报错）。这是按你的“落盘只存 schema_id + entity_id”原则实现的。

如果你希望：
- `from_dict` 时保留/恢复 sub/obj key props  
- 或者 `to_terms` 在缺少 key props 时退化为使用 `entity_id`  
告诉我，我可以补一个可选参数（如 `include_keys=True` / `fallback_entity_id=True`）来控制。




> [!note] ME:

在ir下新创建readme, 并增加解释instance运作的教程

> [!warning] CODEX:

已在 `ir` 目录新增 README，并写了 `Instance` 的完整教程。

文件：`/Users/zhenzhili/symbolic_agent/src/symir/ir/README.md`

如果你希望把这段教程同步到项目根 `README.md`，或想补充更多示例（如 `dict` 形式 rel、`from_dict`、CSV 生成实例），告诉我。





> [!note] ME:

有问题, 我们使用Fact, Rel, FactLayer而不是PredicateSchema等



> [!warning] CODEX:

已按你的要求修正：IR 文档里不再出现 `FactSchema`/`PredicateSchema`，只保留 `Fact` / `Rel` / `FactLayer` 的用户侧表述。  
修改位置：`/Users/zhenzhili/symbolic_agent/src/symir/ir/README.md`

如果你希望我把项目根 `README.md` 或其他公开文档里的 `PredicateSchema/FactSchema` 也替换为 `Fact/Rel/FactLayer`，告诉我范围，我继续改。



> [!note] ME:

问题: prop不出现在用户定义时, 而是通过解析term实现的,



> [!warning] CODEX:

你说得对：**目前 `rel` 的属性值是通过 `terms` 解析出来的**，在 list/tuple 形式下是“隐式按顺序”。这确实容易让用户感觉“不直观”。

好消息是：我们已经支持一种**显式的 props 写法**（dict 形式），但文档里没有强调：

```python
Instance(
    schema=works_at,
    terms={
        "sub_key": {"Name": "bob"},
        "obj_key": {"Company": "openai"},
        "props": {"since": 2020, "title": "researcher"},
    },
)
```

如果你希望**强制 props 必须显式出现**，我可以做以下改动之一（你选一个）：

1. **严格模式：rel 不允许 list/tuple，只允许 dict（含 props）**  
   优点：完全显式，最清晰；缺点：交互输入不够简洁。

2. **兼容模式：保留 list/tuple，但文档强调推荐 dict**  
   优点：兼容人类快速输入；缺点：仍然有“隐式”路径。

3. **新增显式参数**  
   允许：`Instance(schema=rel, terms=[sub, obj], props={...})`  
   优点：清晰且不破坏 list/tuple；缺点：API 变复杂，不再“统一只用 terms”。

你倾向哪种？  
如果你不想再改 API，我可以直接把 README 和示例改成“推荐 dict（含 props）”的方式。



> [!note] ME:

我是说, 你定义Instance时:
works_at_fact = Instance(
    schema=works,
    terms={"subject": "alice", "object": "openai"},
    props={"since": 2020, "title": "researcher"},
)
出现了和terms并列的props不应该出现



> [!warning] CODEX:

对，你说得对：**`Instance` 只有 `terms`，不应该出现并列的 `props` 参数**。  
`props` 只能放在 `terms` 里（dict 形式），或通过 list/tuple 位置解析出来。

**正确写法（rel）**

**1) 推荐：dict + props 显式**
```python
works_at_fact = Instance(
    schema=works,
    terms={
        "sub_key": {"Name": "alice"},
        "obj_key": {"Company": "openai"},
        "props": {"since": 2020, "title": "researcher"},
    },
)
```

**2) 扁平 dict（CSV 友好）**
```python
works_at_fact = Instance(
    schema=works,
    terms={
        "Name": "alice",        # sub key
        "Company": "openai",    # obj key
        "since": 2020,
        "title": "researcher",
    },
)
```

**3) list/tuple（位置解析）**
```python
works_at_fact = Instance(
    schema=works,
    terms=[{"Name": "alice"}, {"Company": "openai"}, 2020, "researcher"],
)
```

如果你希望我在文档里加一句“**Instance 不接受 props 参数，所有数据必须进入 terms**”，我可以补。


