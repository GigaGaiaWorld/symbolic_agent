> [!note] ME:
# 格式改进:
我希望改进Fact的格式将schema_id作为指纹, 并增加key_fields用来存储主键(多个时为复合键, key_fields 顺序固定（建议按 signature 出现顺序）), 
schema id可通过: schema_id = hash(canonical_json({kind,name,signature(signature 全量稳定字段),key_fields})) 计算得到
{
  "kind": "fact",                         // 固定：实体/事实类型
  "name": "person_profile",               // 谓词名（用于展示/映射 label）
  "arity": 3,                             // 参数个数（= signature 长度）
  "schema_id": "fd4c106d...198b8",        // 结构指纹：freeze 后由稳定字段 hash 得到（不含 description）
  "description": "Person with address and age",  // 文案：不参与 schema_id hash

  "signature": [                          // 权威定义：事实的属性字段列表（用于校验/解析/映射）
    {
      "arg_name": "Name",                 // 属性名（也用于 key_fields）
      "datatype": "string",               // 基础类型（先用 string/int/float 足够）
      "namespace": "person",              // 可选：用于分组/展示（不影响运行逻辑可忽略）
      "role": "key"                       // 语义角色：用于推导 key_fields（允许多个 key）
    },
    {
      "arg_name": "Param",
      "datatype": "string",
      "namespace": "address",
      "role": null                        // 非 key 字段
    },
    {
      "arg_name": "Param2",
      "datatype": "int",
      "namespace": "person",
      "role": null
    }
  ],

  "key_fields": ["Name"]                  // freeze 推导并固化：用于计算 entity_id（默认规则见下）
}

同样Rel格式改进: 它的hash由kind, name, sub_schema_id, obj_schema_id, endpoints（或等价地：sub/obj 的 key_fields）, props决定

{
  "kind": "rel",                           // 固定：关系类型
  "name": "employment",
  "arity": 4,                              // 固定：2 + len(props)
  "schema_id": "ab24f136...36de6",         // 结构指纹：freeze 后由稳定字段 hash 得到（不含 derived_signature/description）

  "description": "employment relation with attributes",

  "sub_schema_id": "369a1139...03c1",      // sub 端点的 Fact.schema_id（freeze 将对象引用转成 id）
  "obj_schema_id": "a2315e17...5cca1",     // obj 端点的 Fact.schema_id

  "endpoints": {                           // 端点 key 的权威定义（freeze 推导）
    "sub_key_fields": ["Name"],            // 默认 = sub Fact.key_fields
    "obj_key_fields": ["Company"]          // 默认 = obj Fact.key_fields
  },

  "props": [                               // 关系自有属性（唯一来源）
    {
      "arg_name": "since",
      "datatype": "int",
      "namespace": "time",
      "role": null
    },
    {
      "arg_name": "title",
      "datatype": "string",
      "namespace": "org",
      "role": null
    }
  ],

  "derived_signature": {                   // 仅用于展示/LLM 扁平输出（不参与 schema_id）, 由 freeze 从 endpoints+props 自动生成
    "derived": true,
    "args": [
      {
        "arg_name": "sub_Name",
        "datatype": "string",
        "namespace": "person",
        "role": "sub_key"                  // 表示这是 sub 端点的 key 字段
      },
      {
        "arg_name": "obj_Company",
        "datatype": "string",
        "namespace": "org",
        "role": "obj_key"                  // 表示这是 obj 端点的 key 字段
      },
      {
        "arg_name": "since",
        "datatype": "int",
        "namespace": "time",
        "role": "prop"
      },
      {
        "arg_name": "title",
        "datatype": "string",
        "namespace": "org",
        "role": "prop"
      }
    ]
  }
}

# 对于用户侧 API（易用）
用户定义时直接传 Fact/Rel 对象：
person = Fact("person", [...])
city = Fact("city", [...])
lives_in = Rel("lives_in", sub=person, obj=city, props=[...])
保持目前的定义方式不变, 这里 sub/obj 传的是对象引用，便于 IDE、减少手写 id, 但是freeze 后 Rel 内部必须只保留 sub_schema_id/obj_schema_id，不再依赖 sub/obj 对象引用（避免序列化/循环引用问题）。

如果你有问题或异议可以问我



> [!warning] CODEX:


明白你的规格，我可以按这个方案实现。开始改代码前，需要你确认 3 个细节（以及授权我动手）：

**请确认以下默认实现是否可接受**
1. **`key_fields` 推导规则**  
   我会按你之前约定的优先级：`key > id > name > pos0`，但**顺序严格按 signature 出现顺序**。  
2. **Rel 的 `arity` 计算**  
   我建议用更通用的：  
   `arity = len(sub_key_fields) + len(obj_key_fields) + len(props)`  
   （当 key 是复合键时不会出错）。  
3. **Rel 的 `signature` 与 `derived_signature`**  
   我会让 `Rel.signature` = `derived_signature.args`（内部用于规则/校验），  
   对外 `to_dict` 只输出 `derived_signature`（不输出 `signature`），符合你定义的格式。

**确认后我会做的改动**
- `Fact` 增加并固化 `key_fields`，并参与 schema_id 指纹
- `Rel` 增加 `endpoints`，schema_id 由你指定字段计算
- `Rel` 只保留 `sub_schema_id/obj_schema_id`（不保留对象引用）
- `ArgSpec` JSON 输出字段改为 `arg_name`（内部仍用 `name`）
- 更新相关校验、序列化、缓存读取、约束 schema 与示例

如果以上 OK，请回复：  
**“同意，按你说的做。”**


> [!note] ME:

一个澄清: Rel.signature 必须在 freeze() 时由 endpoints + props 自动生成。

其他同意，按你说的做。




> [!warning] CODEX:

已按你的新格式规范落地，重点变化如下（实现细节都在现有代码里）：

**已实现的规则**
- **Fact**
  - `key_fields` 固化为字段（顺序按 `signature` 出现顺序）
  - `schema_id = hash(canonical_json({kind,name,signature,key_fields}))`
  - `to_dict` 输出 `key_fields`，`arg_name` 字段用于签名
- **Rel**
  - `schema_id = hash(canonical_json({kind,name,sub_schema_id,obj_schema_id,endpoints,props}))`
  - `signature` 在 **freeze/构造** 时由 `endpoints + props` 自动生成  
    - 端点字段使用 `sub_` / `obj_` 前缀
    - role 置为 `sub_key` / `obj_key` / `prop`
  - `to_dict` 不输出 `signature`，只输出 `derived_signature`
  - **不再保留 sub/obj 对象引用**（仅保留 `sub_schema_id/obj_schema_id`）

**对应改动（核心文件）**
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/fact_schema.py`
  - `ArgSpec` 输出 `arg_name`
  - `key_fields` 固化并参与 hash
  - `Rel` 生成 `derived_signature`，并仅保留 `*_schema_id`
- `/Users/zhenzhili/symbolic_agent/src/symir/rules/constraint_schemas.py`
  - `arg_name` 字段同步到约束模型
- `/Users/zhenzhili/symbolic_agent/test.py`
- `/Users/zhenzhili/symbolic_agent/test.ipynb`（注释与示例文字同步）

**未运行测试**（如需我可以跑）

---

有两点需要你确认下一步：
1. 是否要**更新 README** 示例以匹配 `arg_name` / `key_fields` 新格式？
2. 是否要我**提交并 push**这批改动？

另外：仓库里依旧有与你请求无关的变更（`src/symir/samples/*.csv` 被删、`samples/` 和 `test2.ipynb` 新增）。这些我没有动过。要我忽略它们，还是一起处理？