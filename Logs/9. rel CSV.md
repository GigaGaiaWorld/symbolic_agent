
> [!note] ME:

我还是不太明白rel类型数据是如何读取的, 例如
        CSVSource(predicate_id=works.schema_id, file="works_at.csv", columns=["person", "company"]),

> [!warning] CODEX:

关键点：**CSVProvider 是“按 signature 顺序映射”，不是按列名匹配。**  
也就是说 `columns` 只是 CSV 表头的名字，**真正的字段名来自 schema 的 `signature`（rel 是 derived_signature）**。

---

## 实际读取流程（rel）

在 `CSVProvider._load_source` 里，核心逻辑是：

1. 校验 `len(columns) == pred_schema.arity`
2. 对每一行：  
   ```python
   for col, arg_spec in zip(columns, pred_schema.signature):
       value = row[col]          # 从 CSV 用 col 名取值
       terms[arg_spec.name] = value   # 用 schema 的 arg_name 做 key
   ```
3. 然后 `Instance(schema=pred_schema, terms=terms, ...)`

---

## 对 rel 来说，signature 是什么？

`Rel.signature` 是**由 endpoints + props 自动生成**的：

- 先所有 `sub_key_fields` → `sub_` 前缀  
- 再所有 `obj_key_fields` → `obj_` 前缀  
- 最后 `props`

例如：

```python
works = Rel(
    "works_at",
    sub=person,   # key_fields = ["Name"]
    obj=company,  # key_fields = ["Name"]
    props=[ArgSpec("since:int"), ArgSpec("title:string")]
)
```

`works.signature` 等价于：

```
["sub_Name", "obj_Name", "since", "title"]
```

---

## 你的例子：`columns=["person","company"]` 会怎样？

### 情况 A：works 没有 props
`arity=2`，signature = `["sub_Name", "obj_Name"]`

- `columns=["person","company"]` **是可以的**  
- CSV 每行：
  - `person` 列 → 赋给 `sub_Name`
  - `company` 列 → 赋给 `obj_Name`

只要你的 CSV 表头是 `person,company`，就能正确读。

### 情况 B：works 有 props
比如有 `since/title`，signature = `["sub_Name","obj_Name","since","title"]`  
这时 `columns` 必须包含 4 个字段：

```python
columns=["person","company","since","title"]
```

否则会报 **arity mismatch**。

---

## 怎么看 rel 的 signature 顺序？

你可以直接查看：

```python
[(a.arg_name, a.role) for a in works.signature]
```

或者：

```python
works.to_dict()["derived_signature"]
```

---

## 总结（最短版）
- `columns` 是 CSV 表头名，不要求等于 arg_name  
- **映射顺序完全由 `Rel.signature` 决定**  
- `columns` 必须和 `signature` 长度一致  
- 如果你想直观，建议让 CSV 表头直接用 `sub_Name` / `obj_Name` / `since` 这种名字

---

如果你希望 CSVProvider 支持 **“按列名匹配 arg_name”**（而不是只靠顺序），我可以加一个可选模式。

> [!note] ME:

如果想要匹配多个项, 例如觉得只匹配person不够保险, 再加上“address”同时匹配?

> [!warning] CODEX:

可以。做法是把 **person 的 key_fields 设成复合键**（Name + address），Rel 会自动用这个复合键作为 sub 端点匹配条件。这样 entity_id 就由两项共同决定。

**1) 复合 key 的两种写法**

**A. 用 role="key"（推荐）**
```python
person = Fact(
    "person",
    [
        ArgSpec("Name:string", role="key"),
        ArgSpec("address:string", role="key"),
    ],
)
```

**B. 显式 key_fields**
```python
person = Fact(
    "person",
    [ArgSpec("Name:string"), ArgSpec("address:string")],
    key_fields=["Name", "address"],
)
```

---

**2) Rel 默认继承 sub/obj 的 key_fields**

```python
works = Rel(
    "works_at",
    sub=person,          # sub_key_fields = ["Name","address"]
    obj=company,         # obj_key_fields = company.key_fields
    props=[ArgSpec("since:int")],
)
```

这会生成 derived signature：
```
sub_Name, sub_address, obj_Name, since
```

---

**3) CSV 映射（必须按 signature 顺序）**

```python
CSVSource(
    predicate_id=works.schema_id,
    file="works_at.csv",
    columns=["person_name", "person_address", "company_name", "since"],
)
```

这会按顺序映射：
- `person_name` → `sub_Name`
- `person_address` → `sub_address`
- `company_name` → `obj_Name`
- `since` → `since`

---

**4) Instance dict 方式**

```python
Instance(
    schema=works,
    terms={
        "sub_key": {"Name": "bob", "address": "addr1"},
        "obj_key": {"Name": "openai"},
        "props": {"since": 2020},
    },
)
```

---

如果你只想关系里用 Name+address 作为匹配，但 **person 本身的 key_fields 不想变**，也可以在 Rel 里显式指定 endpoints：

```python
works = Rel(
    "works_at",
    sub=person,
    obj=company,
    props=[ArgSpec("since:int")],
    endpoints={"sub_key_fields": ["Name", "address"], "obj_key_fields": ["Name"]},
)
```

要不要我帮你在 `test.py` 或 README 里加一个“复合 key + CSV 映射”的完整示例？
