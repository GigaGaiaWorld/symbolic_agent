> [!note] ME:

我在构想一个优化方案, 它也利于我们兼容neo4j:

对于schema 的定义, 我们进行一些改动:

person_name = ArgSpec("Name:string", namespace="person", role="name")
person_address = ArgSpec("string", namespace="address", role="name")

首先是, 支持语法糖 "City:string" -> name="City", dtype="string"。或者显式的定义参数名, 
city_name = ArgSpec("City:string", namespace="geo", role="name")
country_name = ArgSpec("Country:string", namespace="geo", role="name")
country_established_year = ArgSpec("int", namespace="geo", role="established_year")
role为具有特定效果的参数, role="key"表示强主键, `role="key"` 作为强主键语义；否则 key fallback：`key > id > name > pos0`（按 args 顺序支持复合 key）.
而namespace作为名称空间隔离. 
company_name = ArgSpec("string", namespace="org", role="name")
company_worth = ArgSpec("Worth:float", namespace="org", role="worth")

from symir.rule_ir import Fact, Rel
此外我们不再使用PredicateSchema名称, 而是使用Fact和Rel, Fact是基于PredicateSchema它不限arity数, 我们不再显式的定义arity而是内部自动推出. 
person = Fact("person", [person_name, person_address], description="A person entity")
city = Fact("city", [city_name, country_name], description="A city entity")
company = Fact("company", [company_name,company_worth], description="A company entity")
country = Fact("country", [country_name, country_established_year], description="A country entity")

Rel则是特化作为描述关系的类, 它总是包含一个主语和一个宾语, 如下:
works = Rel("works_at", sub=person, obj=company, description="person works at company")
lives = Rel("lives_in", sub=person, obj=city, description="person lives in city")
located = Rel("located_in", sub=city, obj=country, description="city located in country")
hq = Rel("company_hq", sub=company, obj=city, description="company HQ city")
are_friends = Rel("are_friends", sub=person, obj=person, description="person knows person")
这不仅契合neo4j的表示, 还能后端渲染成:
lives_in(person("Alice","addr1"), city( "DC", "USA")).
的格式. 总而言之 `Fact` 支持任意 arity，`Rel` 固定 sub/obj（二元）。
不过关系实例引用“Instance 对象”可能有隐藏问题.

schema = FactLayer([person, city, company, country, lives, works, located, hq, are_friends])
print("SCHEMA:")
pp.pprint(schema.to_dict())

实例需要增加一些新的元数据: source(数据来源, 例如csv, database, user等)/timestamp/confidence/status（观测/推断/撤回）等, 仿照常规的工程做法, 来方便：回滚、再摄取、冲突解决、只删除某来源数据、时间切片查询。
alice = Instance(id=person.schema_id, terms=["alice","darmstadt"], prob=0.9),
darmstadt = Instance(id=city.schema_id, terms=["darmstadt","germany"]),
facts_from_user = [
    alice,
    Instance(id=person.schema_id, terms=["bob","frankfurt"], prob=0.8),
    Instance(id=city.schema_id, terms=["seattle","usa"], prob=0.95),
    Instance(id=company.schema_id, terms=["openai",10.0]),
    Instance(id=country.schema_id, terms=["usa",1776]),
    Instance(id=lives.schema_id, ref=[alice,darmstadt]), # Use instance reference as terms to link to previously defined facts.
    Instance(id=works.schema_id, subterms=["bob","frankfurt"], objterms=["openai",10.0]), # If only constant terms are provided, according to the assigned parameters of "works", try to resolve "bob" to person_name and "openai" to company_name.
]
这里我想尝试把fact和rel都作为Instance声明, 当然instance还有一种声明方法, 下面再讲.

prob 落地与多证据合并的想法:
    可以：你存 prob，并把合并策略做成可插拔选项。建议你至少定义一个最小公共接口，否则用户“自己决定”会导致同一图里同一关系多条记录无法幂等：
- merge_policy: enum（max / latest / noisy_or / overwrite / keep_all）
- keep_all 时，需要你定义“多版本”表示法：同一关系多条边？还是同一边多个 evidence 节点？这是必须明确的存储策略问题，不是纯算法问题。


此外我们还有rules, 不过现在的rules将分别作为Fact和Rel的变体存在, 即作为它们使用条件语句的版本, 
fact的版本还是正常的
city = Fact("city", [city_name, country_name], description="A city entity")
head = Head(predicate=city, terms=[Var("X"), Var("Y")])

而rel的版本复杂一些:
works = Rel("works_at", sub=person, obj=company, description="person works at company")
head = Head(predicate=head_pred, subterm=[Var("X"), Var("Y")], objterm=[Var("M"), Var("N")])

body的定义一样. 总之rules是抽象层的, 比事实层高一个等级, 不过我们可以将从抽象层推出的事实加入事实层, 同时有时可以利用推理引擎的机制获得事实的概率, 或者合并概率, 在与neo4j协作的场景下, 我们可以想象基于Rel的rules可以像cypher的匹配那样工作, 像是
MATCH (p:Person {name: row.person.name, address: row.person.address})
MATCH (c:City   {name: row.city.name,   country: row.city.country})
MERGE (p)-[r:LIVES_IN]->(c)
创建多个FactInstance (笛卡尔积式的)。即根据schema中定义的参数类型和角色来解析输入的terms，并生成正确的FactInstance。


上面是我优化的想法, 并不是钉死的方案, 如果你觉得哪部分存在隐患或需要调整, 直接和我说


> [!warning] CODEX:

下面是我对你方案的评估与建议，重点放在“Neo4j 兼容性”和“结构稳定性/可维护性”。我不会改代码，先给你评审和问题清单。需要我落地实现时，请你明确同意。

**总体判断**
- 方向是对的：`Fact`（任意 arity）+ `Rel`（sub/obj）更贴近 Neo4j 的图建模，也更容易生成 Cypher。
- 但要真正“稳健可用”，目前还缺一些明确语义，尤其是：主键/属性名、关系方向、类型映射、关系属性、ID 与引用一致性。

**主要风险点（建议优先明确）**
1. `ArgSpec("City:string")` 语法糖  
- 需要**明确语法规则**，否则 `Name:Type` 与 `Type` 的歧义会让解析不可预测。  
- 建议定义 `arg_name` 字段，语法糖解析为 `arg_name="City", datatype="string"`。  
- 当前只有 `role`，没有明确的属性名，Neo4j 属性 key 会不稳定。

2. `role="key"` 与 key fallback 规则  
- 规则是好的，但要**保证可幂等**。  
- 建议明确排序：`role=key` 优先，其次 `id > name > pos0`，且**复合 key 的顺序固定**（由参数定义顺序或明确 `arg_name` 顺序）。

3. `Rel` 的 arity 与关系属性  
- 关系在 Neo4j 上常常有属性（如 `since`, `confidence`）。  
- 你现在 `Rel` 只有 sub/obj，未说明如何挂关系属性。  
- 建议：`Rel` 继承 `Fact`，支持 `props`（ArgSpec 列表），这样 `Rel` 仍然是“二元关系 + 属性”。

4. `schema_id` 的稳定性  
- `Fact` 和 `Rel` 不能只用 `name + signature`，否则同名同签名但类型不同会冲突。  
- 建议 `schema_id` payload 包含 `kind: "fact" | "rel"`，且 `Rel` 包含 `sub.schema_id` / `obj.schema_id`。

5. `Instance` 的引用语义  
- `Instance(id=..., ref=[alice, darmstadt])` 会引入跨 session、跨缓存的隐式依赖。  
- 建议明确 `InstanceRef` 结构（比如 `InstanceRef(schema_id, key_values)`），避免直接持有实例对象导致序列化/缓存问题。  
- 需要保证“只凭 ref 也可解析或复原”。

6. `namespace` 的作用  
- `namespace` 是很好用的隔离，但 Neo4j label 不一定等于 namespace。  
- 需要一个明确映射：  
  - label = `Fact.name`  
  - namespace = 逻辑域  
  - or label = namespace?  
 这个要定义清楚，否则图层会不一致。

7. 规则层与事实层  
- `Rel` 的 rule 版本（subterm/objterm）很好，但要定义：  
  - arity 推导规则  
  - 变量到 ArgSpec 的映射规则  
  - 类型检查失败时的行为  
- 否则会出现隐式推导错误，难以调试。

**对 Neo4j 兼容性的关键缺口总结**
- 关系方向  
- 节点 label 明确规则  
- 属性名明确规则  
- 唯一性/索引/存在性约束  
这些必须在 schema 级可导出，否则只能依赖默认假设。

**我建议的最小可行补足**
- `ArgSpec` 增加 `arg_name`（或 `property_key`）  
- `Rel` 支持 `props`（关系属性）  
- `schema_id` 增加 `kind` + `sub/obj`  
- `Instance` 引用改成 `InstanceRef(schema_id, key_values)`  
- 显式声明 “label 映射规则”

**需要你确认的几个问题**
1. 你希望 label = `Fact.name` 还是 label = `namespace`？  
2. 你是否希望 `Rel` 支持关系属性？  
3. `arg_name` 要不要作为强制字段？  
4. `InstanceRef` 是否可以改成“只存 key values”的结构（不持有实例对象）？  
5. `schema_id` 变更是否可以接受（可能影响旧缓存/旧 schema）？

如果你同意，我可以按你的选择给出一份“最小变更规范”或直接改代码实现。  
需要我继续请明确说“同意继续”。


> [!note] ME:

1. 就像你说的, 我希望label为label = Fact.name 而 namespace = 逻辑域
2. Rel和Fact同样挂关系属性, 因为它自身有新的“name”应该属于新的字段吧
3. arg_name可以不强制, 但是默认名字是“Name”或“Param”
4. 要不把这里改成引用id?
5. 你觉得怎么好就行

> [!warning] CODEX:

收到。你给的 1–3 我已经记下了。下面是我建议的**最小且可落地的规范**，并标出需要你拍板的地方。我不会改代码，等你明确同意再动。

**已确认**
- `label = Fact.name`
- `namespace = 逻辑域`
- `Rel` 和 `Fact` 一样支持属性（关系属性）

**建议的最小规范（可直接实现）**
1. **ArgSpec 增强**
   - 新字段：`arg_name`（用于 Neo4j property key）
   - 语法糖解析：`"City:string"` → `arg_name="City"`, `datatype="string"`
   - 你要求默认名为 “Name” 或 “Param”  
     但 Neo4j 属性名必须唯一，否则会覆盖，建议这样：
     - `role in {"key","name"}` → `arg_name="Name"`
     - 其他 → `arg_name="Param"`
     - **再追加序号确保唯一**：如 `Name1`, `Param2`  
     这样既符合“Name/Param”，又避免冲突。

2. **Fact / Rel**
   - `Fact(name, args, description=None)`  
   - `Rel(name, sub, obj, props=None, description=None)`  
     关系属性走 `props`（ArgSpec 列表）

3. **schema_id 规则（我建议）**
   - `Fact`：`kind="fact" + name + args`
   - `Rel`：`kind="rel" + name + sub.schema_id + obj.schema_id + props`
   - 这样能区分同名不同类型/不同端点

4. **Instance 引用**
   - 不直接存对象引用，改成 `InstanceRef(schema_id, key_values)`  
   - `key_values` 依据 `role` 规则（`key > id > name > pos`）生成  
   - 这样可序列化、缓存、跨进程可复用

---

**需要你拍板的 3 点**
1. `arg_name` 默认名是否允许 **自动加序号**？  
   - 选项 A：`Name/Param` + 序号（推荐）  
   - 选项 B：严格只用 `Name/Param`（可能冲突）

2. Instance 引用是否采用 `InstanceRef(schema_id, key_values)`？  
   - 选项 A：用 `InstanceRef`（推荐、可序列化）  
   - 选项 B：只引用 `instance_id`（需要先生成并保存实例）

3. `schema_id` 变更会使旧缓存失效，你是否接受？  

---

只要你回答这 3 点，并明确说“同意继续”，我就开始改代码。  
如果你希望我先写成**设计文档草案**或**只改一小步**也可以。


> [!note] ME:

都按照你的建议来, 同意继续

> [!warning] 

Summary of changes made
1. Added `arg_name` support and `"Name:type"` syntax to `ArgSpec`, plus default naming (`Name`/`Param` with numeric suffixes) and key selection helpers.
2. Added `Fact`, `Rel`, `InstanceRef`, and `FactLayer` alias. `Rel` now prefixes sub/obj arg names (`sub_{Fact.name}_...` / `obj_{Fact.name}_...`) and supports relation properties.
3. Updated schema id hashing to include `kind`, sub/obj ids, and props; updated Pydantic constraint schemas to include `arg_name`; updated `rule_ir` exports.

Files touched
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/fact_schema.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/rules/constraint_schemas.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/rule_ir.py`

Important: I see unexpected changes I did not make
- Deleted: `/Users/zhenzhili/symbolic_agent/src/symir/samples/*.csv`
- New: `/Users/zhenzhili/symbolic_agent/samples/`, `/Users/zhenzhili/symbolic_agent/test2.ipynb`
- Modified: `/Users/zhenzhili/symbolic_agent/test.ipynb`

How do you want me to proceed with these unrelated changes?