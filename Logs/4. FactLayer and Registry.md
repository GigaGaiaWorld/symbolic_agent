> [!note] ME:

对于registery = FactLayer(
    [person, city, company, country, person_profile, lives, works, located, hq, friend, employment]
)
由于我们的Fact和Rel已经实现构造即冻结, registry 不需要再负责解析, 需要降级, 下面是我对你当前 registry（`FactSchema`/未来可改名 `FactLayer`）的全部修改建议汇总。按“必须改 / 建议改 / 可选改”分层，并把每项的具体落地内容写清楚，便于 Codex 直接动手。

一、必须改（保证可回放、可演化、不 silently wrong）
1. 加入 name-based 索引与访问接口（用户不写 schema_id）
   动机：Instances 回放用 schema_id；用户交互/规则书写用 name。两者都需要。
   落地：
* freeze/构造 registry 时建立：
  * `facts_by_name: dict[str, str]`（name -> schema_id）
  * `rels_by_name: dict[str, str]`
  * 如果允许同名多版本：改为 `dict[str, list[str]]` 并在查询时要求 disambiguation。
* 提供 API：
  * `fact(name) -> Fact`
  * `rel(name) -> Rel`
  * `resolve(kind, name) -> schema_id`
  * 保留 `get(schema_id)` 作为底层权威入口。
1. from_dict/load 时校验 schema_id 一致性（防止加载后悄悄变另一套）
   动机：你目前从 JSON 重建对象会重算 schema_id，但不校验输入的 schema_id，可能导致：
* hash 规则改了 / JSON 被篡改 / 老版本文件 → 读入后 schema_id 变化却不报错。
  落地：
* 解析每个 predicate dict 后重建对象（Fact/Rel）；
* 若输入 dict 含 `schema_id`：必须 `input_schema_id == rebuilt.schema_id`，否则 raise（明确提示“不一致，可能版本不兼容或文件被修改”）。
1. duplicate 检测从“字段拼 key”改为“以 schema_id/名称为准”
   动机：你现在 `_validate()` 用字段组合 key 检查重复，本质重复劳动，且容易跟 schema_id 的定义偏离。
   落地：
* 强约束：
  * `schema_id` 全局唯一（facts + rels）
* 可选强约束（强烈推荐，除非你要多版本同名）：
  * 同 kind 下 `name` 唯一，否则 `fact("person")` 会歧义。
* 如果你允许同名多版本：则要求用户调用 `get(schema_id)` 或 `fact(name, schema_id=...)`。

二、建议改（提升一致性与可维护性）
4. 明确 registry 的角色：构造即冻结下，registry 只做“索引+校验+导入导出”
   动机：你现在已经是 eager-freeze（Fact/Rel 构造时就生成 schema_id、endpoints、signature），registry 不应再做第二套 freeze 计算，避免双源。
   落地：
* 让 `FactSchema.__init__` 做：
  * 收集 predicates
  * build indices（by_id/by_name）
  * validate
* 如果你仍保留 `freeze()`：它只做“build indices + validate”，不再改 schema 内容。
4. 为 rel 建立 signature-key 索引（可选但很实用）
   动机：同名 rel（未来可能）或调试时，需要按 (name, sub_schema_id, obj_schema_id) 快速定位。
   落地：
* `rels_by_triplet[(name, sub_schema_id, obj_schema_id)] -> schema_id`
* 提供：`rel_of(name, sub_fact_name, obj_fact_name)` 或 `rel_of_ids(name, sub_schema_id, obj_schema_id)`。
4. 导出/导入接口标准化（除了 diskcache，也提供显式文件）
   动机：diskcache 适合缓存，但不利于版本管理与迁移；你需要稳定的 schema bundle 文件。
   落地：
* `export_schema_dict() -> {"version":1, "predicates":[...]}`
* `save_schema(path)`
* `load_schema(path) -> FactSchema`
* `version` 用于未来格式变更（不兼容时直接报错）。

三、可选改（现在不用可先不做）
7. FactView / filter（只在你真的要给 LLM 做“允许谓词子集”时保留）
   动机：如果暂时没有“按 namespace/role/标签过滤 schema”的需求，可以先删简化。
   落地：
* 保留最小 API：`facts()` / `rels()` / `predicates()`
* 未来需要再加 view/filter，不影响 core。
7. 增加轻量的 schema “diff/print” 工具（调试友好）
   动机：当 schema 演化时，你需要快速看差异。
   落地：
* `describe(schema_id)`：打印 kind/name/key_fields/endpoints/props
* `diff(schema_id_a, schema_id_b)`（后续再做）

四、你当前实现里最该立刻改的 3 个点（按收益排序）
A) 增加 by_name 索引与 `fact(name)/rel(name)`
B) from_dict/load 校验 schema_id 与重算一致
C) 重写 duplicate 检测：用 schema_id/（可选）name 唯一性替代字段拼 key

五、最终你会得到的 registry 形态（最简但完整）
* 内部存：
  * `_predicates: list[PredicateSchema]`
  * `_by_id: dict[schema_id, PredicateSchema]`
  * `_facts_by_name: dict[name, schema_id]`
  * `_rels_by_name: dict[name, schema_id]`
  * （可选）`_rels_by_triplet: dict[(name, sub_id, obj_id), schema_id]`

* 对外最重要的接口：
  * `get(schema_id)`
  * `fact(name)` / `rel(name)`
  * `resolve(kind, name)`
  * `export_schema_dict()` / `save_schema()` / `load_schema()`

这套改完后，你的系统会同时满足：
* 存储回放靠 schema_id（稳定、可迁移）
* 用户/规则侧靠 name（易用）
* schema 文件可落盘/可加载，且不会 silently wrong
* registry 足够薄，不会和“构造即冻结”的 Fact/Rel 逻辑打架

请给出你的意见和建议




> [!warning] CODEX:

你的建议方向非常正确，我整体同意。下面是我给出的**补充建议 + 需要明确的决策点**（都很小，但能避免后续返工）：

**我同意并建议按以下细节落地**
1. **Rel 的 `arity` 建议用通用公式**  
   `arity = len(sub_key_fields) + len(obj_key_fields) + len(props)`  
   这样天然支持复合键；如果强制 `2 + len(props)`，那等价于只允许每端一个 key，会限制设计。

2. **`derived_signature` 是唯一的 rule/LLM 扁平输出通道**  
   - `Rel.signature` 内部仍必须存在（用于 Rule 校验/渲染）  
   - 对外 `to_dict` 只输出 `derived_signature`，不输出 `signature`  
   这样不会混淆“权威来源”。

3. **from_dict 强校验 schema_id**  
   - 如果输入 dict 中有 `schema_id`，必须与重算一致  
   - 不一致直接抛错，避免“静默错 schema”  
   - 没有 `schema_id` 才允许计算并继续

4. **name 唯一性策略要明确**  
   - 推荐“同 kind 下 name 唯一”，否则 `fact("person")` 会歧义  
   - 如果你要多版本同名：`fact(name, schema_id=...)` 必须要求 disambiguation

5. **Registry 角色降级为 “索引 + 校验 + 导入导出”**  
   完全同意你说的“构造即冻结”后 registry 不该再计算 schema 内容。

**我建议的 API 最小集合（与你的清单一致）**
- `get(schema_id)`
- `fact(name)` / `rel(name)`
- `resolve(kind, name)`（直接给 schema_id）
- `export_schema_dict()` / `save_schema()` / `load_schema()`
- 可选：`rel_of(name, sub_schema_id, obj_schema_id)`

---

如果你认可上述细节，我可以开始按你“必须改/建议改”的清单逐项落地。  
你只需要回复一句：**“开始实现 registry 修改”**。





> [!note] ME:

开始实现 registry 修改





> [!warning] CODEX:


已开始实现并完成 registry 修改（按“必须改”为主，同时加了 `rel_of_ids` 便于定位关系三元组）。

**已改动**
1. Registry 建立 name 索引与新 API：`fact(name)`, `rel(name)`, `resolve(kind, name)`, `rel_of_ids(...)`。  
2. `from_dict` 读取时校验 `schema_id` 是否与重算一致（不一致直接报错）。  
3. 去掉旧的“字段拼 key”重复检测，改为：
   - `schema_id` 全局唯一
   - `fact`/`rel` 名称在各自域内唯一
   - `rel` 三元组 `(name, sub_schema_id, obj_schema_id)` 唯一  
4. 仍保留 `get(schema_id)` 作为权威入口，并继续校验 rel 的 sub/obj 存在且为 fact。

**涉及文件**
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/fact_schema.py`

**我没有运行测试。**

如果你希望我继续做“建议改”的 `export_schema_dict/save_schema/load_schema`，告诉我。  
如果现在要验证行为，我可以加一个最小示例或跑现有测试。



> [!note] ME:

给我展示所有的registry相关api和用法



> [!warning] CODEX:



下面是**所有 registry（`FactSchema` / `FactLayer`）相关 API 与用法**。我按“构建/索引查询/序列化/视图过滤”来分组，示例使用你当前的新语法。

**1) 构建 Registry**
```python
from symir.ir.fact_schema import ArgSpec, Fact, Rel, FactLayer

person = Fact(
    "person",
    [
        ArgSpec("Name:string", namespace="person", role="key"),
        ArgSpec("address:string", namespace="address"),
    ],
    description="A person entity",
)

city = Fact(
    "city",
    [
        ArgSpec("Name:string", namespace="geo", role="key"),
        ArgSpec("Country:string", namespace="geo"),
    ],
    description="A city entity",
)

lives_in = Rel(
    "lives_in",
    sub=person,
    obj=city,
    props=[ArgSpec("since:int", namespace="time")],
    description="person lives in city",
)

registry = FactLayer([person, city, lives_in])  # FactLayer 是 FactSchema 的别名
```

**2) 基础查询 API**
- `predicates()`  
  返回 registry 中的所有 schema（`PredicateSchema` 列表）。
```python
all_preds = registry.predicates()
```

- `get(schema_id)`  
  用 `schema_id` 获取 schema（权威入口）。
```python
person_schema = registry.get(person.schema_id)
```

- `fact(name)`  
  用名称获取 Fact。
```python
person_schema = registry.fact("person")
```

- `rel(name)`  
  用名称获取 Rel。
```python
lives_schema = registry.rel("lives_in")
```

- `resolve(kind, name)`  
  用名称解析为 `schema_id`。
```python
person_id = registry.resolve("fact", "person")
lives_id = registry.resolve("rel", "lives_in")
```

- `rel_of_ids(name, sub_schema_id, obj_schema_id)`  
  用三元组 `(name, sub_id, obj_id)` 精确定位关系。
```python
lives_schema = registry.rel_of_ids("lives_in", person.schema_id, city.schema_id)
```

**3) 序列化 / 反序列化**
- `to_dict()`  
  导出 registry 到 dict。
```python
payload = registry.to_dict()
```

- `FactLayer.from_dict(data)`  
  从 dict 载入并**校验 schema_id 一致性**。
```python
loaded = FactLayer.from_dict(payload)
```

**4) 视图/过滤（FactView）**
- `view(schema_ids)`  
  生成一个只允许特定 schema_id 的视图。
```python
view = registry.view([person.schema_id, lives_in.schema_id])
```

- `view_from_filter(filt)`  
  使用 filter AST 生成视图（依赖 `symir.ir.filters.apply_filter`）。
```python
view = registry.view_from_filter(my_filter_ast)
```

**FactView API**
- `allows(schema_id)`  
  判断是否允许某 schema。
```python
view.allows(person.schema_id)
```

- `predicates()`  
  返回视图内所有 schema。
```python
view_preds = view.predicates()
```

---

**补充说明**
- 当前 registry 假设 `fact/rel` 名称在各自域内唯一；`schema_id` 必须全局唯一。  
- `from_dict` 会强校验 `schema_id` 与重算结果一致，否则直接报错。  
- `FactLayer` 与 `FactSchema` 完全等价，只是命名更贴合概念。

如果你希望我补一个“最小可运行 demo”或把这些 API 示例加进 `test.py`/文档里，告诉我。




> [!note] ME:

是不是没有实现export_schema_dict() / save_schema() / load_schema()


> [!warning] CODEX:

是的，目前还没有实现 `export_schema_dict()` / `save_schema()` / `load_schema()`，只有 `to_dict()` / `from_dict()`。

要我现在加这三个 API 吗？如果要，请告诉我：
1. 文件格式：`json` 还是 `yaml`
2. 是否需要 `version` 字段（我建议加，默认 `1`）



> [!note] ME:

不需要这几个, 因为to_dict()和from_dict(payload)实现了, 不过可以给registry加上version, 你觉得呢?



> [!warning] CODEX:

建议加一个 `version`，价值很高、改动很小。做法如下：

- `to_dict()` 返回 `{"version": 1, "predicates": [...]}`  
- `from_dict()`：  
  - 若没有 `version`，默认当作 `1`  
  - 若有且不是 `1`，直接报“不兼容版本”  

如果你同意，我就加这一点。只需要你确认一句：“加 version”。



> [!note] ME:

除了version, 还有工程上建议做的吗

> [!warning] CODEX:

有，工程上我还建议这些（都不必做，但很有价值）：

- `to_dict()` 固定顺序输出（按 `kind/name` 排序），保证序列化结果稳定、易 diff。
- 便捷 API：`facts()` / `rels()` / `names()`，减少外部过滤逻辑。
- 名称规范化策略（可选）：统一大小写或 trim，避免 `Person`/`person` 误差。
- 可选“多版本同名”策略开关：现在是强制唯一；若将来要并行版本，可加 `allow_multiple_names=True` 并返回列表或要求 disambiguation。
- 最小调试工具：`describe(schema_id)` 输出关键字段（kind/name/key_fields/endpoints/props），排查 schema 演化更快。

如果你想做其中任何一项，我可以直接改。

> [!note] ME:

都采用

> [!warning] CODEX:

已按“都采用”完成改动，全部落在 `/Users/zhenzhili/symbolic_agent/src/symir/ir/fact_schema.py`。要点如下：

- Registry 增加 `version`，`to_dict()` 输出 `{"version": 1, "predicates": [...]}`，`from_dict()` 校验版本（缺省视为 1）。
- `to_dict()` 现在稳定排序（按 `kind/name/schema_id`），保证序列化结果可 diff。
- 新增便捷 API：`facts()` / `rels()` / `names()` / `describe(schema_id)`。
- 名称规范化：索引与查询统一做 `strip().lower()`，保证大小写不敏感、前后空格不影响查找。
- 既有 `fact(name) / rel(name) / resolve(kind, name) / rel_of_ids(...)` 全部支持上述规范化。

**新 API 使用示例**
```python
# 便捷列表
registry.facts()        # list of fact predicates
registry.rels()         # list of rel predicates
registry.names()        # {"facts": [...], "rels": [...]}

# 规范化查找（大小写不敏感）
registry.fact("Person")
registry.rel("LIVES_IN")
registry.resolve("fact", "person")

# 关系三元组定位
registry.rel_of_ids("lives_in", person.schema_id, city.schema_id)

# 描述信息（调试/排错）
registry.describe(person.schema_id)
```

**提醒**
- 名称规范化只影响索引与查询，不改变 `PredicateSchema.name` 原值。
- 我没有运行测试。

如果你希望把这些新 API 示例同步到 `test.py` / `test.ipynb`，告诉我。



