
> [!note] ME:

回到instance的merge, 它究竟如何实现?

> [!warning] CODEX:

目前 **merge 并没有真正实现**。  
现有代码里所谓 “merge_policy” 只是 **元数据标记**，真正做的事情只有：

- `meta.merge_policy == "keep_all"` 时生成 `record_id`（用于幂等/区分多条记录）
- 其它 policy（`max/latest/noisy_or/overwrite`）**没有任何执行逻辑**

**证据位置**
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py`  
  - `_compute_record_id(...)`  
  - `Instance.__init__` 中只有对 `merge_policy="keep_all"` 的处理  
- `CSVProvider` / `Renderer` 只是产出/消费 `Instance`，没有合并行为  
  - `/Users/zhenzhili/symbolic_agent/src/symir/fact_store/provider.py`

所以回答你的问题：**目前 merge 只是“记录意图”，并未实现合并算法。**

---

如果你想让 merge 真正发生，我可以做一个明确的合并器（例如 `merge_instances(instances, policy)`），规则可以按你之前提的：

- fact 主键：`entity_id`
- rel 主键：`schema_id + sub_entity_id + obj_entity_id`  
- `keep_all`：全部保留  
- `max`/`latest`/`noisy_or`/`overwrite`：按策略输出一条

但我会等你确认策略细节后再动手。

> [!note] ME:

只有当我确认才能生成,
我们先确定一下merge_instances究竟如何实现, 我的构想同样根据entity_id来划分, 我觉得是否可以给rel格式的实例也增加entity_id, 然后merge直接在相同entity_id的实例间进行? 是否合理? 有什么问题?

> [!warning] CODEX:

可以，但要注意：**给 rel 加 `entity_id` 本质上只是把 `(schema_id, sub_entity_id, obj_entity_id)` 哈希成一个字段**，并不会增加信息。  

### 结论（工程评价）
**合理，但要小心语义误导**：
- 如果 `rel_entity_id` 只基于端点，那么**同一对端点 + 不同 props**会被当成同一关系去 merge。  
- 这在“关系有时态/角色/多条证据”时会丢信息。  
- 因此这个做法**只适合**你愿意把“端点对”当作关系唯一性时。

### 主要问题
1. **多关系歧义**  
   一对端点可能有多条关系（不同时间/不同职位/不同证据）。  
   若 rel_id 只看端点，会被 merge 掉。

2. **props 不能参与唯一性**  
   目前 rel 没有 `key_fields` 概念，无法指定“哪些 props 参与身份”。

3. **“entity_id”命名误导**  
   rel 的“身份”不一定等价于实体主键，工程上更常叫 `edge_id` 或 `rel_id`。

---

## 推荐做法（稳妥）
**不强制给 rel 存 entity_id，直接用 group_key：**
```
fact: (schema_id, entity_id)
rel : (schema_id, sub_entity_id, obj_entity_id)
```
这与 “rel_entity_id = H(schema_id + sub_entity_id + obj_entity_id)” 等价，只是更透明。

然后由 **merge_policy** 决定是否合并：
- `keep_all`：全保留
- `latest/max/noisy_or/overwrite`：合并成一条

---

## 如果你坚持加 rel_id
可以加，但需要明确：
- rel_id = H(schema_id + sub_entity_id + obj_entity_id)  
- 它只代表“端点对”，不代表“完整关系记录”  
- **若要区分多条关系，必须 `keep_all` 或另设 identity_fields**  

---

## 你需要定的关键点（请确认）
1. **rel 是否允许“多条记录”作为常态？**  
   - 是 → 默认 `keep_all`，或引入 `rel_identity_fields`
   - 否 → 端点对视作唯一关系，merge 合并即可

2. **merge_instances 遇到 props 冲突怎么办？**  
   - `latest`：保留最新 props
   - `max`：保留最大 prob 的整条
   - `noisy_or`：prob 合并，但 props 用哪一条？

---

如果你愿意，我可以给出一个**明确的 merge_instances 规则草案**（不动代码），你确认后再实现。


> [!note] ME:

我同意你的推荐做法, 
此外我完全不知情目前的meta包含哪些词条

> [!warning] CODEX:

好的，我先确认你同意的 merge 分组方式：

- **fact 合并 key**：`(schema_id, entity_id)`
- **rel 合并 key**：`(schema_id, sub_entity_id, obj_entity_id)`  
（可以在 merge 内部再 hash 成一个 `rel_key`，但本质一样）

---

关于你问的 **meta 词条**：

### 目前代码里的“实际情况”
**`meta` 是完全自由的 dict，没有强制字段。**  
代码目前只“真正使用”了这些：

- `merge_policy`  
  - 只有当 `merge_policy == "keep_all"` 时才会生成 `record_id`
- `evidence_id`  
  - 如果存在，用来生成 `record_id`
- 如果 `evidence_id` 缺失，会 fallback 用：
  - `props` + `source` + `observed_at` + `ingested_at` 计算一个替代 evidence id

对应代码位置：  
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py`  
  - `_compute_record_id(...)`  
  - `Instance.__init__` 中处理 `merge_policy`

---

### 你之前建议的“推荐字段”
这些字段**目前只是约定，并未强制**：

- `source`
- `observed_at`
- `ingested_at`
- `confidence`
- `status`
- `evidence_id`
- `trace_id`
- `provenance`
- `tags`
- `merge_policy`

---

如果你希望“meta 有明确标准”，我可以做两件事：

1. **把推荐字段写进 README**（你现在就能看见）
2. **增加校验器**（比如 `validate_meta()` / pydantic 模型）

你希望我先做哪一个？

> [!note] ME:

先增加校验器

> [!warning] CODEX:

已增加 **meta 校验器**，并写入 README 说明。

**实现行为**
- `meta` 只要提供，就会校验已知字段的类型与取值范围
- 未知字段不会报错（仍允许扩展）

**校验规则**
- `source` / `observed_at` / `ingested_at` / `evidence_id` / `trace_id` 必须是字符串  
- `confidence` 必须是 `[0.0, 1.0]` 数值  
- `status` 必须是 `asserted | inferred | retracted`  
- `merge_policy` 必须是 `max | latest | noisy_or | overwrite | keep_all`  
- `provenance` 必须是 dict  
- `tags` 必须是字符串列表  

**文件**
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/README.md`

如果你希望“未知字段直接报错”或需要支持更多 meta 字段类型，我可以继续加。


> [!note] ME:

是不是有一些词条不应该挂在Instance上, 而是schema上?

> [!warning] CODEX:

是的，有些词条更适合放在 **schema 层**，而不是每条 Instance。粗略划分如下：

## 更适合 **schema**（结构/策略级）
- **合并策略默认值**：`merge_policy`（这是“该谓词如何合并”的规则，更像 schema 的属性）  
- **稳定语义**：`description` / `namespace` / `role` / `key_fields` / `endpoints`（已在 schema）
- **约束/业务规则**：允许值范围、唯一性要求、默认状态、版本等

## 更适合 **instance**（观测/证据级）
- `source` / `observed_at` / `ingested_at`
- `confidence`
- `status`（asserted / inferred / retracted）
- `evidence_id` / `trace_id`
- `provenance`
- `tags`

### 推荐实践
- **`merge_policy` 放到 schema 做默认值**，instance 可以覆盖（少数情况）。  
- 观测类字段始终放在 instance。

---

当前实现里 `meta` 仍是 instance 级别的自由字典，只是做了类型校验。  
如果你希望，我可以：

1. 在 `Fact/Rel` 增加 `meta` 或 `schema_meta`（例如 `default_merge_policy`）。  
2. `Instance` 创建时如果 `meta.merge_policy` 不填，就从 schema 继承。  
3. README 中明确“schema vs instance”的归属规则。

你要我这样拆分并实现吗？

> [!note] ME:

帮我拆分, 但是对于Fact/Rel, 不使用meta, 而是直接增加选项. 记得这些拆分的, 应该在meta中去掉.
meta作为自由字典是不是不太好? 如果我们希望meta每项都有对应的功能, 那多了或少了会不会有问题?

> [!warning] CODEX:


已按你的要求拆分并收紧 `meta`：

**变更摘要**
1. **`merge_policy` 移到 schema 层**
   - `Fact` / `Rel` 直接新增 `merge_policy` 参数  
   - `meta.merge_policy` 已废弃，传入会报错  
   - `record_id` 的生成依据 **schema 的 `merge_policy`**

2. **`meta` 变为严格字典**
   - 只允许已定义的键  
   - 任何未知键都会抛 `SchemaError`

**允许的 meta 字段（严格）**
- `source`, `observed_at`, `ingested_at`, `evidence_id`, `trace_id`（字符串）
- `confidence`（0-1）
- `status`（`asserted|inferred|retracted`）
- `provenance`（dict）
- `tags`（字符串列表）

**文件**
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/fact_schema.py`  
  - `Fact/Rel` 新增 `merge_policy`  
  - `PredicateSchema.to_dict/from_dict` 支持 `merge_policy`
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py`  
  - `meta` 严格校验  
  - `merge_policy` 仅从 schema 读取  
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/README.md`  
  - 文档更新（schema 层 merge_policy + meta 严格）

**使用示例**
```python
person = Fact(
    "person",
    [ArgSpec("Name:string", role="key")],
    merge_policy="keep_all",
)

instance = Instance(
    schema=person,
    terms=["alice"],
    meta={"source": "csv", "observed_at": "2026-02-10T12:00:00Z"},
)
```

如果你还想把 **某些 meta 字段也上移到 schema**（例如 `default_status`），告诉我具体字段，我可以继续拆分。



> [!note] ME:

对于一些literal, 能不能增加选项? 像是status, merge_policy=merge_policy,这些

> [!warning] CODEX:

可以加，但要先明确 **“literal”指的是哪一层**，以及这些选项的**语义**。

我先按最可能的理解回答：

**如果你说的是 rule 层的 `RefLiteral`（`symir.ir.rule_schema.RefLiteral`）**
- 可以加 `options` 或显式字段如 `status`  
- **`merge_policy` 不适合放在 literal**，因为它是“数据合并策略”，应该是 schema 层的默认行为，不是查询/推理时的匹配条件  
- `status` 倒是合理，作为“只匹配 asserted/inferred/retracted 的事实”的过滤条件

但需要你确认：  
1. `status` 是**用于匹配过滤**，还是只作为注释保留？  
2. 这些选项要不要影响 `Renderer` / `RuleValidator`？  
3. 是否只加在 `RefLiteral`，还是 `ExprLiteral` 也要支持？

---

**如果你说的是 Instance 的 literal（事实输入）**  
那就不用加——`status` 已经在 meta 里，且现在是严格校验；`merge_policy` 已上移到 schema。

---

请你确认：
- 你指的是 **哪一种 literal**？  
- 你希望 `status` / `merge_policy` **实际参与匹配**，还是仅仅记录？  

你确认后我再改代码。

> [!note] ME:

我的意思是
status（asserted|inferred|retracted）这是三种选项
而
merge_policy也有不同的merge 方式, 如果用户填入merge_policy=”my_ass"那肯定不对啊

> [!warning] CODEX:

已经有了，都是**强校验**：

**1) `merge_policy`（schema 层）**  
- 只能是：`max | latest | noisy_or | overwrite | keep_all`  
- 其他值会直接 `SchemaError`  
- 校验位置：`/Users/zhenzhili/symbolic_agent/src/symir/ir/fact_schema.py`（`PredicateSchema.__post_init__`）

**2) `status`（instance meta）**  
- 只能是：`asserted | inferred | retracted`  
- 校验位置：`/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py`（`_validate_meta`）

**3) `meta.merge_policy` 禁用**  
- 现在 `meta` 不允许 `merge_policy`，会直接报错：  
  “`meta.merge_policy is deprecated; set merge_policy on the schema.`”

**4) `meta` 是严格字典**  
- 未知 key 直接报错，避免随意塞字段。

---

如果你想让 **literal（规则里的 `RefLiteral`）也支持 `status` 过滤**，我可以加，但这会影响 `RuleValidator/Renderer` 的语义，需要你确认规则层是否要用这个字段。


> [!note] ME:

我希望在用户输入的时候能看到这些选项, 例如在type中写Literal["...

> [!warning] CODEX:

已完成：现在这些选项会以 `Literal[...]` 的形式出现在类型提示里，IDE 会直接给出候选值。

**改动点**
- `merge_policy` 在 schema 层用 `MergePolicy = Literal[...]` 限定  
- `status` 在 instance meta 层用 `Status = Literal[...]` 限定  
- `meta` 使用 `InstanceMeta`（TypedDict）做严格结构化提示  
- `meta` 仍然严格校验，未知 key 会报错

**涉及文件**
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/fact_schema.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/rule_ir.py`（方便统一 import）
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/README.md`（补充示例）

**示例（会有 IDE 提示）**
```python
from symir.ir.fact_schema import MergePolicy
from symir.ir.instance import Status, InstanceMeta

policy: MergePolicy = "keep_all"
status: Status = "asserted"
meta: InstanceMeta = {"source": "csv", "status": status}
```

如果你还希望把这些类型导出到其它入口（例如 `symir.ir.__init__`），我可以补。

> [!note] ME:

对于“现在 meta 不允许 merge_policy，会直接报错：
“meta.merge_policy is deprecated; set merge_policy on the schema.””
不用这样, 直接把merge_policy从meta去除即可

此外from symir.ir.fact_schema import MergePolicy
from symir.ir.instance import Status, InstanceMeta
这样太麻烦了吧, 我是说直接在参数定义的地方使用merge_policy:Literal["...",...]不行吗?

> [!warning] CODEX:

Done. Changes applied per your request:

- Removed the special `meta.merge_policy is deprecated...` error.
- `merge_policy` now uses `Literal[...]` directly in `Fact/Rel` parameter type hints.
- Removed the extra `MergePolicy/Status/InstanceMeta` exports and README imports.
- Cleaned unused imports in `instance.py`.

**Note**: `meta` is still strict. If someone passes `merge_policy` inside `meta`, it will now fail as an **unknown meta key** (no special message).

**Files touched**
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/fact_schema.py`
- `/Users/zhenzhili/symbolic_agent/src/symir/ir/README.md`
- `/Users/zhenzhili/symbolic_agent/src/symir/rule_ir.py`

If you want `meta` to ignore unknown keys (instead of error), say the word and I’ll relax it.


> [!note] ME:

要不要直接设置merge_policy默认值为keep all?

> [!warning] CODEX:

不建议默认 `keep_all`。

**原因（工程取舍）**
- `keep_all` 会让同一实体/关系出现多条记录，后续查询/推理必须再做去重或聚合。
- 默认 `keep_all` 会让大部分普通场景（比如 CSV 导入）变成“每条证据都保留”，数据量和噪声都会放大。
- 更合理的默认是 **`None`**（不合并策略），由上层显式选择，或在特定 schema 上设定。

**推荐策略**
- 默认：`merge_policy=None`
- 仅在确实需要多证据并存时，对该 Fact/Rel 显式设置：
  ```python
  person = Fact(..., merge_policy="keep_all")
  ```

如果你仍然想“全局默认 keep_all”，可以加一个全局配置（例如 `FactLayer(default_merge_policy="keep_all")`），但不建议作为硬默认。

> [!note] ME:

meta应该怎么设置

> [!warning] CODEX:


`meta` 现在是**严格字典**，只能使用以下字段（其它会报错）：

**允许字段**
- `source`: str（数据来源，如 `"csv" | "db" | "user"`）
- `observed_at`: str（源数据时间）
- `ingested_at`: str（入库时间）
- `confidence`: float（0~1）
- `status`: `"asserted" | "inferred" | "retracted"`
- `evidence_id`: str（证据稳定 ID）
- `trace_id`: str（一次导入/任务追踪 ID）
- `provenance`: dict（结构化溯源）
- `tags`: list[str]

**示例**
```python
meta = {
    "source": "csv",
    "observed_at": "2026-02-10T12:00:00Z",
    "ingested_at": "2026-02-10T12:03:00Z",
    "confidence": 0.82,
    "status": "asserted",
    "evidence_id": "row:123",
    "trace_id": "import_20260210_001",
    "provenance": {"file": "people.csv", "row": 123},
    "tags": ["imported", "manual_ok"],
}

instance = Instance(schema=person, terms=["alice", "berlin"], meta=meta)
```

**要点**
- `merge_policy` 已移到 schema（Fact/Rel），不能放在 meta。
- `meta` 的字段是“有功能含义”的：比如 `merge_policy="keep_all"` 时会用 `evidence_id` 生成 `record_id`。

如果你想让 meta 更宽松（允许额外字段），我可以改成 “未知字段仅警告” 或 “忽略未知字段”。


> [!note] ME:

只是确保README包含了所有用户需要知悉的内容

> [!warning] CODEX:

已更新并对齐 README（项目根 `README.md`）内容，确保用户需要知悉的内容都在文档里：

**已补充/澄清的关键信息**
- `merge_policy` 只能在 `Fact/Rel` 上设置，并列出允许值：`max | latest | noisy_or | overwrite | keep_all`
- `meta` 是严格字典，列出允许字段，明确“未知 key 会报错”
- `Instance` 的常用创建方式与 `include_keys=True` 的可读输出
- `CSVProvider` 的真实列映射规则与 `datatype_cast` 选项
- 新旧 CSV 方案分离（`Fact/Rel` + `CSVProvider` 为主，旧的 `ir.schema` 为 legacy）

**修改文件**
- `/Users/zhenzhili/symbolic_agent/README.md`

如果你希望我同时把这些补充同步到 `src/symir/ir/README.md`（或你指定的其它文档），告诉我路径。
