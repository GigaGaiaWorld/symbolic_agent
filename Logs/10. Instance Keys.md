
> [!note] ME:

Instance的创建时
Instance(
    schema=works_at,
    terms={
        "sub_key": {"Name": "bob"},
        "obj_key": {"Company": "openai"},
        "since": 2020,
        "title": "researcher",
    },
)
也是让sub_key和obj_key包含所有的项?

> [!warning] CODEX:

不是。“`sub_key` / `obj_key` 只负责端点主键”，**不包含 props**。  
在你这个写法里：

```python
terms={
    "sub_key": {"Name": "bob"},
    "obj_key": {"Company": "openai"},
    "since": 2020,
    "title": "researcher",
}
```

**当前实现会忽略 `since/title`**（它只会读取 `props` 字段）。  
正确写法是：

```python
Instance(
    schema=works_at,
    terms={
        "sub_key": {"Name": "bob"},
        "obj_key": {"Company": "openai"},
        "props": {"since": 2020, "title": "researcher"},
    },
)
```

结论：
- `sub_key/obj_key` **必须覆盖该端点的全部 key_fields**（比如 key_fields 是 `["Name","address"]`，就必须都给）。
- props 必须放到 `props` 里，或者使用**扁平 dict 形式**（不带 `sub_key/obj_key`）：

```python
Instance(
    schema=works_at,
    terms={
        "Name": "bob",      # sub key
        "Company": "openai",# obj key
        "since": 2020,
        "title": "researcher",
    },
)
```

如果你希望在 `sub_key/obj_key` 分支下 **遇到顶层多余字段直接报错**，我可以加一个严格校验来避免误用。

> [!note] ME:

我是说包含所有key_fields中的项是吗?

> [!warning] CODEX:

是的。  
`sub_key` / `obj_key` **必须包含该端点所有 `key_fields`**，否则会报错（strict 模式下）。

- `sub_key` 必须覆盖 `Rel.endpoints.sub_key_fields`
- `obj_key` 必须覆盖 `Rel.endpoints.obj_key_fields`

如果缺任何一项，会报：
```
SchemaError: Rel endpoint missing key fields: [...]
```

> [!note] ME:

同时id的计算也是利用key_fields中所有的项?

> [!warning] CODEX:

当前实现里 **entity_id 直接只用 `key_fields` 的字段名和值**。  
但 **间接会受 `datatype/namespace/role` 影响**，因为 `schema_id` 本身是由 `signature`（包含 `datatype/namespace/role/arg_name`）+ `key_fields` 计算出来的。

所以结论是：

- **直接参与 entity_id 的**：`schema_id` + key_fields 的值  
- **间接参与的**：`datatype/namespace/role`（它们影响 `schema_id`，从而影响 entity_id）

公式等价于：

```
entity_id = H( schema_id + canonical_json(ordered(key_fields values)) )
```

只要 schema 发生变化导致 `schema_id` 变化，entity_id 就会变。




> [!note] ME:

entity_id考虑'datatype': 'string',
                                'namespace': 'geo',
                                'role': 'name'等参数吗? 还是只考虑arg_name?

> [!warning] CODEX:

当前实现里 **entity_id 直接只用 `key_fields` 的字段名和值**。  
但 **间接会受 `datatype/namespace/role` 影响**，因为 `schema_id` 本身是由 `signature`（包含 `datatype/namespace/role/arg_name`）+ `key_fields` 计算出来的。

所以结论是：

- **直接参与 entity_id 的**：`schema_id` + key_fields 的值  
- **间接参与的**：`datatype/namespace/role`（它们影响 `schema_id`，从而影响 entity_id）

公式等价于：

```
entity_id = H( schema_id + canonical_json(ordered(key_fields values)) )
```

只要 schema 发生变化导致 `schema_id` 变化，entity_id 就会变。

> [!note] ME:

看起来key_fields被重复计算了?

> [!warning] CODEX:

对，你观察得很准确：**`key_fields` 的“名称集合”确实出现在两个层面**：

- `schema_id` 的 hash 里包含 `key_fields` 列表  
- `entity_id` 计算时又把 `key_fields` 对应的 **(name, value)** 序列做了一次 canonical hash  
  （见 `/Users/zhenzhili/symbolic_agent/src/symir/ir/instance.py` 的 `_compute_entity_id`）

这不是 bug，而是**保守设计**：

- `schema_id` 绑定“schema 定义版本”（包含 key_fields 名称）
- `entity_id` 绑定“具体实体值”
- 两者合起来可确保：**只要 schema 定义变化，实体 id 也变化**，避免旧数据与新 schema 误合并

不过你说的“重复”也成立——因为 `key_fields` 名称已经在 `schema_id` 里了，所以 `entity_id` 中再带 name 有点冗余。  
如果你想简化，可以改成：

```
entity_id = H(schema_id + canonical_json(ordered_values_only))
```

这依然安全（schema_id 已携带 key_fields 定义），只是少了一层冗余。

要不要我改成“只 hash key_values”（不带 key 名）？  
如果要，我会在 `Instance._compute_entity_id` 改成只用 values，并更新文档。


> [!note] ME:

哦canonical_json(ordered(key_fields values)实际上是实际的值例如“Alice”? 那没事了

> [!warning] CODEX:

对，`ordered(key_fields values)` 里是具体值（比如 `"Alice"`、`"NYC"`），不是字段名。  
所以不会“重复 key 名”，只是用 schema_id 锁定结构，用 key 值锁定实体。

> [!note] ME:

而entity_id会考虑props吗?

> [!warning] CODEX:

不会。  
`entity_id` **只使用 `key_fields` 对应的值**，其它 `props` 不参与。  
如果某个字段不在 `key_fields`，它改变也不会影响 `entity_id`。  
只有当该字段被标记为 key（进入 `key_fields`）时才会影响。


> [!note] ME:

那一个rel类型的instance, 使用不同的props时它们的id是一样的?

> [!warning] CODEX:

简短回答：**是的**，当前实现里 **rel 的 `sub_entity_id` / `obj_entity_id` 不受 props 影响**。  
所以**同一对端点**但不同 props 的 rel instance，会有**相同的端点 id**。

更完整一点：

- rel 没有单独的 “relation_id”  
- 只有 `sub_entity_id` 和 `obj_entity_id`（由端点 key_fields 计算）  
- **props 不参与端点 id 计算**

如果你需要区分“同一对端点、不同 props”的多条记录，可以用：

- `meta.merge_policy="keep_all"` 让系统生成 `record_id`  
  - 若 `evidence_id` 提供 → `record_id` 不含 props  
  - 若 `evidence_id` 缺失 → fallback 会把 `props` 也纳入 hash  

所以你要 **props 影响唯一性**，就要：
- 给每条记录不同 `evidence_id`，或  
- 我们改 `record_id` 逻辑让它必含 props（如果你希望我改，告诉我）。

> [!note] ME:

“简短回答：是的，当前实现里 rel 的 sub_entity_id / obj_entity_id 不受 props 影响。
所以同一对端点但不同 props 的 rel instance，会有相同的端点 id。” 这是bug还是有意为之的?

> [!warning] CODEX:

这是**有意为之**，不是 bug。  
当前设计把 **端点身份**（`sub_entity_id` / `obj_entity_id`）和 **关系属性**（`props`）分开：  
- 端点 id 只由端点 key_fields 决定  
- props 只作为“关系的附加属性”，不影响端点 id

这样做的好处是：**同一对端点可以有多条关系记录**，而不是被 props 变化导致“新关系”。  
如果你要区分这些记录，应该使用 `record_id`（`merge_policy="keep_all"` 时会生成）。

---

如果你更倾向把 props 也纳入“关系的唯一性”，有两个改法（我可以帮你实现）：

1. **让 `record_id` 永远包含 props**（即使有 evidence_id）  
   → 关系=端点+props

2. **新增 `rel_id`**  
   例如：`rel_id = H(schema_id + sub_entity_id + obj_entity_id + props)`  
   并作为 canonical 字段保存

你倾向哪种？


> [!note] ME:

不用, 只是请清晰的写到readme中

> [!warning] CODEX:

已写入 README，明确说明：

- `entity_id` 只由 `schema_id + key_fields values` 决定  
- rel 的 `sub_entity_id/obj_entity_id` 仅由端点 key_fields 决定，**props 不影响**  
- 需要区分多条关系记录时，用 `merge_policy="keep_all"` 生成 `record_id`

文件：`/Users/zhenzhili/symbolic_agent/src/symir/ir/README.md`

> [!note] ME:



> [!warning] CODEX:



