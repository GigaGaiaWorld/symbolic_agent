

> [!note] ME:

from symir.rules.constraint_schemas import (
    build_pydantic_rule_model,
    build_responses_schema,
    build_predicate_catalog,
)
它们需要和当前的rule适配


> [!warning] CODEX:

已适配到当前 Rule 结构（`conditions` + `Ref.schema_id`）。核心变化：

**已改动**
- `build_pydantic_rule_model`：`Ref`/literal 里的字段从 `predicate_id` 改为 `schema_id`。
- `build_responses_schema`：JSON schema 里也改为 `schema_id`（verbose 和 compact 都一致）。
- `build_predicate_catalog`：保持以 `schema_id` 为 key，不变。
- `parse_llm_response.py`：读取 `schema_id`。
- `Ref` 本体改为 `schema_id` 字段（渲染与验证器同步更新）。

**现在 LLM 输出应该长这样（verbose）**
```json
{
  "conditions": [
    {
      "literals": [
        {
          "kind": "ref",
          "schema_id": "…",
          "terms": [
            {"kind": "var", "name": "X"},
            {"kind": "const", "value": "alice"}
          ],
          "negated": false
        }
      ],
      "prob": 0.7
    }
  ]
}
```

如果你希望 **继续兼容旧的 `predicate_id`**，我可以在 pydantic 和 JSON schema 里加 alias。当前是严格只接受 `schema_id`。

> [!note] ME:

然后从
resp = client.responses.create(
    model="gpt-4o-2024-08-06",
    instructions=system_prompt,
    input=user_prompt,
    text={
        "format": {
            "type": "json_schema",
            "name": "cases_only_contract",
            "schema": json_schema,
            "strict": True,
        }
    },
)
得到的payload, 构建回Rule, 我在想是否类似FactLayer, 我们使用一个
registry = RuleLayer(
    [works_at, has_age]
)
RuleLayer来register规则, 或者从payload中读取成Rule?

> [!warning] CODEX:


可以，但要先澄清一件事：**当前 JSON schema 只解码 `conditions`，不包含 head**。  
所以 LLM 的 payload **不能单独构造成 Rule**，必须由你在调用时提供 head（或从外部 registry 里找到 head）。

### 推荐流程（现状最稳）
```python
json_schema = build_responses_schema(view, library=lib, mode="compact")

resp = client.responses.create(...)
rule = resp_to_rule(
    resp,
    head=works_at,   # 你传入 head（Fact/Rel）
    view=view,
    library=lib,
    mode="compact",
)
```

### 关于 `RuleLayer`
你可以做一个 `RuleLayer`，但它更像是**规则集合/索引容器**，而不是“从 LLM payload 直接还原 Rule”的工具。  
建议定位：

**RuleLayer 适合做：**
- 按 `predicate.schema_id` / `predicate.name` 索引规则
- 批量导入导出规则（完整 rule dict）
- 版本化/去重（可选）

**RuleLayer 不适合做：**
- 直接用 LLM payload（只有 `conditions`）构建规则  
  因为 payload 里缺 head，必须外部补。

### 如果你希望 payload 本身就能还原 Rule
可以扩展 schema，把 head 一并输出，例如：
- `head_schema_id`
- 或 `head`（完整 predicate dict）

但这样会使 prompt + 约束更复杂（LLM 容易重复输出大段 head）。

---

**结论**  
- **RuleLayer 可以做**，但它主要是“规则集合管理”，不是 LLM 解码器。
- **从 payload 直接构建 Rule 不可行**，除非扩展 schema 让 head 也在 payload 里。

如果你想，我可以给你设计一个最小 `RuleLayer`（索引 + 去重 + 导入导出），或者改 `build_responses_schema` 让它包含 `head_schema_id`。

